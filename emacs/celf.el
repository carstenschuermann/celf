;;; Modes and utilities for Celf programming.  This package supports (1)
;;; editing Celf source files with reasonable indentation, (2) managing
;;; configurations of Celf source files, including TAGS tables, (3)
;;; communication with an inferior Celf server to type-check and execute
;;; declarations and queries, (4) interaction with an inferior Celf process
;;; in SML.
;;;
;;; For documentation, type C-h m in Celf mode, or see the function
;;; celf-mode below
;;;
;;; Author: Frank Pfenning
;;; Thu Oct 7 19:48:50 1993 (1.0 created)
;;; Fri Jan 6 09:06:38 1995 (2.0 major revision)
;;; Tue Jun 16 15:49:31 1998 (3.0 major revision)
;;;
;;;======================================================================
;;; For the `.emacs' file (copied from init.el)
;;;======================================================================
;;;
;;; ;; Tell Emacs where the Celf libraries are.
;;; (setq load-path
;;;       (cons "/afs/cs/project/celf/research/celf/emacs" load-path))
;;; 
;;; ;; Autoload libraries when Celf-related major modes are started.
;;; (autoload 'celf-mode "celf" "Major mode for editing Celf source." t)
;;; (autoload 'celf-server "celf" "Run an inferior Celf server." t)
;;; (autoload 'celf-sml "celf" "Run an inferior Celf-SML process." t)
;;; 
;;; ;; Switch buffers to Celf mode based on filename extension,
;;; ;; which is one of .elf, .quy, .thm, or .cfg.
;;; (setq auto-mode-alist
;;;       (cons '("\\.elf$" . celf-mode)
;;; 	    (cons '("\\.quy$" . celf-mode)
;;; 		  (cons '("\\.thm$" . celf-mode)
;;; 			(cons '("\\.cfg$" . celf-mode)
;;; 			      auto-mode-alist)))))
;;; 
;;; ;; Default Celf server program location
;;; (setq celf-server-program
;;;       "/afs/cs/project/celf/research/celf/bin/celf-server")
;;; 
;;; ;; Default Celf SML program location
;;; (setq celf-sml-program
;;;       "/afs/cs/project/celf/misc/smlnj/bin/sml-cm")
;;;
;;; ;; Default documentation location (in info format)
;;; (setq celf-info-file
;;;       "/afs/cs/project/celf/research/celf/doc/info/celf.info")
;;; 
;;; ;; Automatically highlight Celf sources using font-lock
;;; (add-hook 'celf-mode-hook 'celf-font-fontify-buffer)
;;;
;;;======================================================================
;;; Command Summary
;;;======================================================================
;;;
;;; Quick summary of Celf mode, generated from C-h b:
;;;
;;; --- Editing Commands ---
;;; TAB          celf-indent-line
;;; DEL          backward-delete-char-untabify
;;; M-C-q        celf-indent-decl
;;;
;;; --- Type Checking ---
;;; C-c C-c      celf-save-check-config
;;; C-c C-a      celf-save-append-config
;;; C-c C-s      celf-save-check-file
;;; C-c C-d      celf-check-declaration
;;; C-c c        celf-type-const
;;; C-c C-u      celf-server-display
;;;
;;; --- Error Tracking ---
;;; C-c `        celf-next-error
;;; C-c =        celf-goto-error
;;;
;;; --- Syntax Highlighting ---
;;; C-c C-l      celf-font-fontify-decl
;;; C-c l        celf-font-fontify-buffer
;;;
;;; --- Server State ---
;;; C-c <        celf-set
;;; C-c >        celf-get
;;; C-c C-i      celf-server-interrupt
;;; M-x celf-server
;;; M-x celf-server-configure
;;; M-x celf-server-quit
;;; M-x celf-server-restart
;;; M-x celf-server-send-command
;;;
;;; --- Timers ---
;;; M-x celf-timers-reset
;;; M-x celf-timers-show
;;; M-x celf-timers-check
;;;
;;; --- Tags (standard Emacs etags package) ---
;;; M-x celf-tag
;;; M-.          find-tag (standard binding)
;;; C-x 4 .      find-tag-other-window (standard binding)
;;; C-c q        tags-query-replace (Celf mode binding)
;;; C-c s        tags-search (Celf mode binding)
;;; M-,          tags-loop-continue (standard binding)
;;;              visit-tags-table, list-tags, tags-apropos
;;;
;;; --- Communication with inferior Celf-SML process (not Celf Server) ---
;;; M-x celf-sml
;;; C-c C-e      celf-sml-send-query
;;; C-c C-r      celf-sml-send-region
;;; C-c RET      celf-sml-send-newline
;;; C-c ;        celf-sml-send-semicolon
;;; C-c d        celf-sml-cd
;;; M-x celf-sml-quit
;;;
;;; --- Variables ---
;;; celf-indent        amount of indentation for nested Celf expressions
;;;
;;;======================================================================
;;; Some Terminology
;;;======================================================================
;;;
;;; Celf Server --- an inferior process that services requests to type-check,
;;; load, or execute declarations and queries.  It is usually attached to the
;;; buffer *celf-server*.  Requests are generated by Emacs from user commands,
;;; or may be typed directly into the Celf server buffer.
;;;
;;; Current configuration --- A configuration is an ordered list of
;;; Celf source files in dependency order.  It is usually initialized
;;; and maintained in a file sources.cfg.  The current configuration is
;;; also the bases for the TAGS file created by celf-tag.  This allows
;;; quick jumping to declaration sites for constants, or to apply
;;; searches or replacements to all files in a configuration.
;;;
;;; Current Celf declaration --- When checking individual declarations
;;; Emacs must extract it from the current buffer and then send it to
;;; the server.  This is necessarily based on a heuristic, since Emacs
;;; does not know enough in order to parse Celf source properly in all
;;; cases, but it knows the syntax for comments, Celf identifiers, and
;;; matching delimiters.  Search for the end or beginning of a
;;; declaration is always limited by double blank lines in order to be
;;; more robust (in case a period is missing at the end of a
;;; declaration).  If the point falls between declarations, the
;;; declaration after the point is considered current.
;;;
;;; Celf-SML --- During development or debugging of the Celf
;;; implementation itself it is often useful to interact with SML, the
;;; language in which Celf is implementated, rather than using an Celf
;;; server.  This is an inferior SML process which may run a Celf
;;; query interpreter.
;;;
;;;======================================================================
;;; Change Log
;;;======================================================================
;;;
;;; Thu Jun  3 14:51:35 1993 -fp
;;; Added variable display-elf-queries.  If T (default) redisplays Elf
;;; buffer after a query has been sent.  Delays one second after sending
;;; the query which is rather arbitrary.
;;; Wed Jun 30 19:57:58 1993
;;; - Error messages in the format line0.col0-line1.col1 can now be parsed.
;;; - Error from std_in, either interactive or through elf-send-query
;;;   can now be tracked.
;;; - Added simple directory tracking and function elf-cd, bound to C-c d.
;;; - improved filename completion in Elf mode under Lucid Emacs.
;;; - replaced tail recursion in elf-indent-line by a while loop.
;;; - changed elf-input-filter to ignore one character inputs.
;;; - elf-error-marker is now updated on every interactive input or send.
;;; - added commands elf-send-newline, bound to C-c RET
;;;   and elf-send-semicolon, bound to C-c ;.
;;;   These are useful when sending queries from a buffer with examples.
;;; Fri Sep  3 15:02:10 1993
;;; Changed definition of elf-current-paragraph so that it recognizes
;;; individual declarations within a traditional ``paragraph'' (separated
;;; by blank lines).
;;; Fri Oct 22 10:05:08 1993
;;; Changed elf-send-query to ensure that the Elf process expects a query
;;; If the Elf process is at the SML prompt, it starts a top level.
;;; If the Elf process is waiting after printing an answer substitution,
;;; it sends a RET.
;;; This is based on a heuristic analysis of the contents of the Elf buffer.
;;; Fri Dec 16 15:27:14 1994
;;; Changed elf-error-marker to elf-error-pos, since it moved in undesirable
;;; ways in Emacs 19.
;;; Fri Jan  6 09:06:54 1995
;;; Major revision: incorporating elf-server.el and elf-tag.el
;;; Thu Jan 12 14:31:36 1995
;;; Finished major revision (version 2.0)
;;; Sat Jun 13 12:14:34 1998
;;; Renamed to Celf and incorporated menus from elf-menu.el
;;; Major revision for Celf 1.2 release
;;; Q: Improve tagging for %keyword declarations?
;;; Thu Jun 25 08:52:41 1998
;;; Finished major revision (version 3.0)
;;; Fri Oct  2 11:06:15 1998
;;; Added NT Emacs bug workaround
;;; Wed Dec 12 14:36:48 2001
;;; Some emacs versions include easymenu already, and auc-menu can conflict.
;;; Changed to not require auc-menu in this case.

(require 'comint)
(condition-case nil
    (require 'easymenu)
  (file-error
   (require 'auc-menu)))

;;;----------------------------------------------------------------------
;;; User visible variables
;;;----------------------------------------------------------------------

(defvar celf-indent 3
  "*Indent for Celf expressions.")

(defvar celf-infix-regexp ":\\|\\<->\\>\\|\\<<-\\>\\|\\<=\\>"
  "*Regular expression to match Celf infix operators.
Match must exclude surrounding whitespace.  This is used for indentation.")

(defvar celf-server-program "celf-server"
  "*Default Celf server program.")

(defvar celf-info-file "celf.info"
  "*Default info file for Celf.")

(defvar celf-server-display-commands nil
  "*If non-nil, the Celf server buffer will be displayed after each command.
Normally, the Celf server buffer is displayed only after some selected
commands or if a command is given a prefix argument.")

(defvar celf-highlight-range-function 'celf-highlight-range-zmacs
  "*Function which highlights the range analyzed by the server.
This is called for certain commands which apply to a subterm at point.
You may want to change this for FSF Emacs, XEmacs and/or highlight packages.")

(defvar celf-focus-function 'celf-focus-noop
  "*Function which focusses on the current declaration or query.
This is called for certain commands which pick out (a part of) a declaration
or query.  You may want to change this for FSF Emacs, XEmacs and/or highlight
packages.")

(defvar celf-server-echo-commands t
  "*If nil, Celf server commands will not be echoed in the Celf server buffer.")

(defvar celf-save-silently nil
  "*If non-nil, modified buffers are saved without confirmation
before `celf-check-config' if they belong to the current configuration.")

(defvar celf-server-timeout 5
  "*Number of seconds before the server is considered delinquent.
This is unsupported in some versions of Emacs.")

(defvar celf-sml-program "celf-sml"
  "*Default Celf-SML program.")

(defvar celf-sml-args '()
  "*Arguments to Celf-SML program.")

(defvar celf-sml-display-queries t
  "*If nil, the Celf-SML buffer will not be selected after a query.")

(defvar celf-mode-hook '()
  "List of hook functions to run when switching to Celf mode.")

(defvar celf-server-mode-hook '()
  "List of hook functions to run when switching to Celf Server mode.")

(defvar celf-config-mode-hook '()
  "List of hook functions to run when switching to Celf Config minor mode.")

(defvar celf-sml-mode-hook '()
  "List of hook functions for Celf-SML mode.")

(defvar celf-to-celf-sml-mode '()
  "List of hook functions for 2Celf-SML minor mode.")

(defvar celf-config-mode nil
  "Non-NIL means the Celf Config minor mode is in effect.")

(defvar celf-check-config-clears-server-buffer nil
  "If non-NIL, celf-check-config clears the server buffer before any
new output is written.  This improves memory usage when repeatedly
checking large systems of files.")

;;;----------------------------------------------------------------------
;;; Internal variables
;;;----------------------------------------------------------------------

(defvar *celf-server-buffer-name* "*celf-server*"
  "The default name for the Celf server buffer.")

(defvar *celf-server-buffer* nil
  "The buffer with the Celf server if one exists.")

(defvar *celf-server-process-name* "celf-server"
  "Name of the Celf server process.")

(defvar *celf-config-buffer* nil
  "The current Celf configuration buffer if one exists.")

(defvar *celf-config-time* nil
  "The modification time of Celf configuration file when read by the server.")

(defvar *celf-config-list* nil
  "The reversely ordered list with files in the current Celf configuration.")

(defvar *celf-server-last-process-mark* 0
  "The process mark before the last command in the Celf server buffer.")

(defvar *celf-last-region-sent* nil
  "Contains a list (BUFFER START END) identifying the last region sent
to the Celf server or Celf-SML process for error tracking.
If nil, then the last input was interactive.
If t, then the last input was interactive, but has already been copied
to the end of the Celf-SML buffer.")

(defvar *celf-last-input-buffer* nil
  "Last buffer to which input was sent.
This is used by the error message parser.")

(defvar *celf-error-pos* 0
  "Last error position in the server buffer.")

(defconst *celf-read-functions*
  '((nat . celf-read-nat)
    (bool . celf-read-bool)
    (limit . celf-read-limit)
    (strategy . celf-read-strategy)
    (tablestrategy . celf-read-tablestrategy)
    (tracemode . celf-read-tracemode))
  "Association between Celf parameter types and their Emacs read functions.")

(defconst *celf-parm-table*
  '(("chatter" . nat)
    ("doubleCheck" . bool)
    ("unsafe" . bool)
    ("autoFreeze" . bool)
    ("Print.implicit" . bool)
    ("Print.depth" . limit)
    ("Print.length" . limit)
    ("Print.indent" . nat)
    ("Print.width" . nat)
    ("Trace.detail" . nat)
    ("Recon.trace" . bool)
    ("Recon.traceMode" . tracemode)
    ("Compile.optimize" . bool)
    ("Prover.strategy" . strategy)
    ("Prover.maxSplit" . nat)
    ("Prover.maxRecurse" . nat)
    ("Table.strategy" . tablestrategy)
    ("Table.strengthen" . bool))
  "Association between Celf parameters and their types.")

(defvar celf-chatter "3"
  "Chatter level in current Celf server.
Maintained to present reasonable menus.")

(defvar celf-batch-chatter "3"
  "Chatter level in current Celf server while running batch commands.
Applies when checking or appending a config, or loading a file.  May
be reduced relative to \\[celf-chatter] to load large configs faster
while remaining verbose enough during interactive commands,
e.g. \\[celf-check-declaration].")

(defvar celf-double-check "false"
  "Current value of doubleCheck Celf parameter.")

(defvar celf-unsafe "false"
  "Current value of unsafe Celf parameter.")

(defvar celf-auto-freeze "true"
  "Current value of autoFreeze Celf parameter.")

(defvar celf-print-implicit "false"
  "Current value of Print.implicit Celf parameter.")

(defvar celf-trace-detail "1"
  "Trace detail in current Celf server.")

(defvar celf-trace-history ()
  "History list of inputs to trace and break commands.
Maintained to present reasonable menus.")

(defvar celf-compile-optimize "true"
  "Current value of Compile.optimize Celf parameter.")

(defvar celf-recon-trace "false"
  "Current value of Recon.trace parameter.")

(defvar celf-recon-tracemode ()
  "Current value of Recon.traceMode parameter.")

(defconst *celf-track-parms*
  '(("chatter" . celf-chatter)
    ("doubleCheck" . celf-double-check)
    ("unsafe" . celf-unsafe)
    ("autoFreeze" . celf-auto-freeze)
    ("Print.implicit" . celf-print-implicit)
    ("Recon.trace" . celf-recon-trace)
    ("Recon.traceMode" . celf-recon-tracemode)
    ("Trace.detail" . celf-trace-detail)
    ("Compile.optimize" . celf-compile-optimize))
  "Association between Celf parameters and Emacs tracking variables.")

;;;----------------------------------------------------------------------
;;; Basic key bindings
;;;----------------------------------------------------------------------

(defun install-basic-celf-keybindings (map)
  "General key bindings for Celf and Celf Server modes."
  ;; Additional tag keybindings
  (define-key map "\C-cq" 'tags-query-replace)
  (define-key map "\C-cs" 'tags-search)
  ;; Server state
  (define-key map "\C-c<" 'celf-set)
  (define-key map "\C-c>" 'celf-get)
  ;; Error handling
  (define-key map "\C-c`" 'celf-next-error)
  (define-key map "\C-c=" 'celf-goto-error)
  ;; Proper indentation
  (define-key map "\e\C-q" 'celf-indent-decl)
  (define-key map "\t" 'celf-indent-line)
  (define-key map "\177" 'backward-delete-char-untabify)
  ;; Info documentation
  (define-key map "\C-c\C-h" 'celf-info)
  )

;;;----------------------------------------------------------------------
;;; Celf mode
;;; This mode should be used for files with Celf declarations,
;;; usually *.elf, *.quy, or *.thm, and Celf configuration files *.cfg
;;;----------------------------------------------------------------------

(defun install-celf-keybindings (map)
  "Install the key bindings for the Celf mode."
  (define-key map "\C-cl" 'celf-font-fontify-buffer) ;autoload celf-font
  (define-key map "\C-c\C-l" 'celf-font-fontify-decl) ;autoload celf-font
  (define-key map "\C-c\C-i" 'celf-server-interrupt)
  (define-key map "\C-c\C-u" 'celf-server-display)
  (define-key map "\C-cc" 'celf-type-const)
  ;(define-key map "\C-ce" 'celf-expected-type-at-point)
  ;(define-key map "\C-cp" 'celf-type-at-point)
  ;(define-key map "\C-c." 'celf-complete)
  ;(define-key map "\C-c?" 'celf-completions-at-point)
  (define-key map "\C-c\C-d" 'celf-check-declaration)
  (define-key map "\C-c\C-s" 'celf-save-check-file)
  (define-key map "\C-c\C-c" 'celf-save-check-config)
  (define-key map "\C-c\C-a" 'celf-save-append-config)
  )

(defvar celf-mode-map nil
  "The keymap used in Celf mode.")

(cond ((not celf-mode-map)
       (setq celf-mode-map (make-sparse-keymap))
       (install-basic-celf-keybindings celf-mode-map)
       (install-celf-keybindings celf-mode-map)))

;;;----------------------------------------------------------------------
;;; General editing and indentation
;;;----------------------------------------------------------------------

(defvar celf-mode-syntax-table nil
  "The syntax table used in Celf mode.")

(defun set-celf-syntax (char entry)
  (modify-syntax-entry char entry celf-mode-syntax-table))
(defun set-word (char) (set-celf-syntax char "w   "))
(defun set-symbol (char) (set-celf-syntax char "_   "))

(defun map-string (func string)
  (if (string= "" string)
      ()
    (funcall func (string-to-char string))
    (map-string func (substring string 1))))

(if celf-mode-syntax-table
    ()
  (setq celf-mode-syntax-table (make-syntax-table))
  ;; A-Z and a-z are already word constituents
  ;; For fontification, it would be better if _ and ' were word constituents
  (map-string 'set-word "!&$^+/<=>?@~|#*`;,-0123456789\\") ; word constituents
  (map-string 'set-symbol "_'")         ; symbol constituents
  ;; Delimited comments are %{ }%, see 1234 below.
  (set-celf-syntax ?\ "    ")            ; whitespace
  (set-celf-syntax ?\t "    ")           ; whitespace
  (set-celf-syntax ?% "< 14")            ; comment begin
  (set-celf-syntax ?\n ">   ")           ; comment end
  (set-celf-syntax ?: ".   ")            ; punctuation
  (set-celf-syntax ?. ".   ")            ; punctuation
  (set-celf-syntax ?\( "()  ")           ; open delimiter
  (set-celf-syntax ?\) ")(  ")           ; close delimiter
  (set-celf-syntax ?\[ "(]  ")           ; open delimiter
  (set-celf-syntax ?\] ")[  ")           ; close delimiter
  (set-celf-syntax ?\{ "(}2 ")           ; open delimiter
  (set-celf-syntax ?\} "){ 3")           ; close delimiter
  ;; Actually, strings are illegal but we include:
  (set-celf-syntax ?\" "\"   ")          ; string quote
  ;; \ is not an escape, but a word constituent (see above)
  ;;(set-celf-syntax ?\\ "/   ")         ; escape
  )

(defconst *whitespace* " \t\n\f"
  "Whitespace characters to be skipped by various operations.")

(defconst *celf-comment-start* (concat "%[%{" *whitespace* "]")
  "Regular expression to match the start of a Celf comment.")

(defconst *celf-id-chars* "a-z!&$^+/<=>?@~|#*`;,\\-\\\\A-Z_0-9'"
  "Characters that constitute Celf identifiers.")

(defun skip-celf-comments-and-whitespace ()
  "Skip Celf comments (single-line or balanced delimited) and white space."
  (skip-chars-forward *whitespace*)
  (while (looking-at *celf-comment-start*)
    (cond ((looking-at "%{")		; delimited comment
	   (forward-char 2)
	   (let ((comment-level 1))
	     (while (and (> comment-level 0)
			 (re-search-forward "\\(%{\\)\\|\\(}%\\)" nil 'limit))
	       (cond
		((match-beginning 1) (setq comment-level (1+ comment-level)))
		((match-beginning 2) (setq comment-level (1- comment-level)))))))
	  (t				; single-line comment
	   (end-of-line 1)))
    (skip-chars-forward *whitespace*)))

(defun celf-end-of-par-x (%define-ends-decl &optional limit)
  "Skip to presumed end of current Celf declaration.
Moves to next period or blank line (whichever comes first)
and returns t if period is found, nil otherwise.
If %define-ends-decl, consider %define and %solve as equivalent
to period for the purposes of identifier fontification.
Skips over comments (single-line or balanced delimited).
Optional argument LIMIT specifies limit of search for period."
  (if (not limit)
      (save-excursion
        (forward-paragraph 1)
        (setq limit (point))))
  (if (and %define-ends-decl
	   (looking-at "%define"))
      (forward-char 1))
  (while (and (not (looking-at "\\.\\W"))
	      (not (looking-at "\\.\\'"))
	      (not (and %define-ends-decl
			(or (looking-at "%define")
			    (looking-at "%solve"))))
	      (< (point) limit))
    (skip-chars-forward "^.%" limit)
    (cond ((looking-at *celf-comment-start*)
	   (skip-celf-comments-and-whitespace))
	  ((and %define-ends-decl
		(or (looking-at "%define")
		    (looking-at "%solve")))
	   t)
	  ((looking-at "%")
	   (forward-char 1))
	  ((looking-at "\\.\\w")
	   (forward-char 1))))
  (cond ((looking-at "\\.")
         (forward-char 1)
         t)
	((and %define-ends-decl
	      (looking-at "%define"))
	 t)
        (t ;; stopped at limit
         nil)))

(defun celf-end-of-par (&optional limit)
  "Skip to presumed end of current Celf declaration.
Moves to next period or blank line (whichever comes first)
and returns t if period is found, nil otherwise.
Skips over comments (single-line or balanced delimited).
Optional argument LIMIT specifies limit of search for period."
  (celf-end-of-par-x nil limit))

(defun celf-font-end-of-par (&optional limit)
  "Skip to presumed end of current Celf declaration.
Moves to next period or blank line (whichever comes first)
and returns t if period is found, nil otherwise.
Considers %define and %solve as equivalent
to period for the purposes of identifier fontification.
Skips over comments (single-line or balanced delimited).
Optional argument LIMIT specifies limit of search for period."
  (celf-end-of-par-x t limit))

(defun celf-current-decl ()
  "Returns list (START END COMPLETE) for current Celf declaration.
This should be the declaration or query under or just before
point within the nearest enclosing blank lines.
If declaration ends in `.' then COMPLETE is t, otherwise nil."
  (let (par-start par-end complete)
    (save-excursion
      ;; Skip backwards if between declarations
      (if (or (eobp) (looking-at (concat "[" *whitespace* "]")))
          (skip-chars-backward (concat *whitespace* ".")))
      (setq par-end (point))
      ;; Move forward from beginning of decl until last
      ;; declaration before par-end is found.
      (if (not (bobp)) (backward-paragraph 1))
      (setq par-start (point))
      (while (and (celf-end-of-par par-end)
                  (< (point) par-end))
        (setq par-start (point)))
      ;; Now par-start is at end of preceding declaration or query.
      (goto-char par-start)
      (skip-celf-comments-and-whitespace)
      (setq par-start (point))
      ;; Skip to period or consective blank lines
      (setq complete (celf-end-of-par))
      (setq par-end (point)))
    (list par-start par-end complete)))

(defun celf-mark-decl ()
  "Marks current Celf declaration and moves point to its beginning."
  (interactive)
  (let* ((par (celf-current-decl))
         (par-start (nth 0 par))
         (par-end (nth 1 par)))
    (push-mark par-end)
    (goto-char par-start)))

(defun celf-indent-decl ()
  "Indent each line of the current Celf declaration."
  (interactive)
  (let* ((par (celf-current-decl))
         (par-start (nth 0 par))
         (par-end (nth 1 par)))
    (goto-char par-start)
    (celf-indent-lines (count-lines par-start par-end))))

(defun celf-indent-region (from to)
  "Indent each line of the region as Celf code."
  (interactive "r")
  (cond ((< from to)
         (goto-char from)
         (celf-indent-lines (count-lines from to)))
        ((> from to)
         (goto-char to)
         (celf-indent-lines (count-lines to from)))
        (t nil)))

(defun celf-indent-lines (n)
  "Indent N lines starting at point."
  (interactive "p")
  (while (> n 0)
    (celf-indent-line)
    (forward-line 1)
    (setq n (1- n))))

(defun celf-comment-indent ()
  "Calculates the proper Celf comment column.
Currently does not deal specially with pragmas."
  (cond ((looking-at "%%%")
         0)
        ((looking-at "%[%{]")
         (car (celf-calculate-indent)))
        (t
         (skip-chars-backward " \t")
         (max (if (bolp) 0 (1+ (current-column))) comment-column))))

(defun looked-at ()
  "Returns the last string matched against.
Beware of intervening, even unsuccessful matches."
  (buffer-substring (match-beginning 0) (match-end 0)))

(defun celf-indent-line ()
  "Indent current line as Celf code.
This recognizes comments, matching delimiters, and standard infix operators."
  (interactive)
  (let ((old-point (point)))
    (beginning-of-line)
    (let* ((indent-info (celf-calculate-indent))
           (indent-column (nth 0 indent-info))
           (indent-type (nth 1 indent-info))
           (indent-string (nth 2 indent-info)))
      (skip-chars-forward " \t")        ; skip whitespace
      (let ((fwdskip (- old-point (point))))
        (cond ((looking-at "%%%")
	       (celf-indent-line-to 0 fwdskip)) ; %%% comment at column 0
              ((looking-at "%[%{]")     ; delimited or %% comment
               (celf-indent-line-to indent-column fwdskip))
              ((looking-at *celf-comment-start*)    ; indent single-line comment
               (indent-for-comment)
               (forward-char -1))
	      ((looking-at "%")		; %keyword declaration
	       (celf-indent-line-to indent-column fwdskip))
              ((looking-at celf-infix-regexp) ; looking at infix operator
               (if (string= indent-string (looked-at))
                   ;; indent string is the same as the one we are looking at
                   (celf-indent-line-to indent-column fwdskip)
                 (celf-indent-line-to (+ indent-column celf-indent) fwdskip)))
              ((eq indent-type 'delimiter) ; indent after delimiter
               (celf-indent-line-to (+ indent-column celf-indent) fwdskip))
              ((eq indent-type 'limit)  ; no delimiter or infix found.
               (celf-indent-line-to indent-column fwdskip))
              ((eq indent-type 'infix)
               (celf-indent-line-to (+ indent-column celf-indent) fwdskip)))))))

(defun celf-indent-line-to (indent fwdskip)
  "Indent current line to INDENT then skipping to FWDSKIP if positive.
Assumes point is on the first non-whitespace character of the line."
  (let ((text-start (point))
        (shift-amount (- indent (current-column))))
    (if (= shift-amount 0)
        nil
      (beginning-of-line)
      (delete-region (point) text-start)
      (indent-to indent))
    (if (> fwdskip 0)
        (forward-char fwdskip))))

(defun celf-calculate-indent ()
  "Calculate the indentation and return a list (INDENT INDENT-TYPE STRING).
INDENT is a natural number,
INDENT-TYPE is 'DELIMITER, 'INFIX, or 'LIMIT, and
STRING is the delimiter, infix operator, or the empty string, respectively."
  (save-excursion
    (let* ((par (celf-current-decl))
           (par-start (nth 0 par))
           (par-end (nth 1 par))
           (par-complete (nth 2 par))
           (limit (cond ((> par-start (point)) (point))
                        ((and (> (point) par-end) par-complete) par-end)
                        (t par-start))))
      (celf-dsb limit))))

(defun celf-dsb (limit)
  "Scan backwards from point to find opening delimiter or infix operator.
This currently does not deal with comments or mis-matched delimiters.
Argument LIMIT specifies bound for backwards search."
  (let ((result nil)
        (lparens 0) (lbraces 0) (lbrackets 0))
    (while (not result)
      (if (or (= lparens 1) (= lbraces 1) (= lbrackets 1))
          (setq result (list (current-column) 'delimiter (looked-at)))
        (if (re-search-backward (concat "[][{}()]\\|" celf-infix-regexp)
                                limit 'limit) ; return 'LIMIT if limit reached
            (let ((found (looked-at)))
              (cond
               ((string= found "(") (setq lparens (1+ lparens)))
               ((string= found ")") (setq lparens (1- lparens)))
               ((string= found "{") (setq lbraces (1+ lbraces)))
               ((string= found "}") (setq lbraces (1- lbraces)))
               ((string= found "[") (setq lbrackets (1+ lbrackets)))
               ((string= found "]") (setq lbrackets (1- lbrackets)))
               (t;; otherwise, we are looking at an infix operator
                (if (and (= lparens 0) (= lbraces 0) (= lbrackets 0))
                    (setq result (list (current-column) 'infix found))
                  nil))))               ; embedded - skip
          (setq result (list 0 'limit ""))))) ; reached the limit, no indent
    result))

(defun celf-mode-variables ()
  "Set up local variables for Celf mode."
  (set-syntax-table celf-mode-syntax-table)
  ;; Paragraphs are separated by blank lines or ^L.
  (make-local-variable 'paragraph-start)
  (setq paragraph-start "^[ \t\f]*$")
  (make-local-variable 'paragraph-separate)
  (setq paragraph-separate paragraph-start)
  (make-local-variable 'indent-line-function)
  (setq indent-line-function 'celf-indent-line)
  (make-local-variable 'comment-start)
  (setq comment-start "%")
  (make-local-variable 'comment-start-skip)
  (setq comment-start-skip "%+{?[ \t]*")
  (make-local-variable 'comment-end)
  (setq comment-end "")
  (make-local-variable 'comment-column)
  (setq comment-column 40)
  ;; (make-local-variable 'parse-sexp-ignore-comments)
  ;; (setq parse-sexp-ignore-comments t)
  )

(defun celf-mode ()
  "Major mode for editing Celf code.
Tab indents for Celf code.
Delete converts tabs to spaces as it moves back.
M-C-q indents all lines in current Celf declaration.

Celf mode also provides commands to maintain groups of Celf source
files (configurations) and communicate with an Celf server which
processes declarations.  It also supports quick jumps to the (presumed)
source of error message that may arise during parsing or type-checking.

Customisation: Entry to this mode runs the hooks on celf-mode-hook.
See also the hints for the .emacs file given below.

Mode map
========
\\{celf-mode-map}
\\<celf-mode-map>
Overview
========

The basic architecture is that Emacs sends commands to an Celf server
which runs as an inferior process, usually in the buffer *celf-server*.
Emacs in turn interprets or displays the replies from the Celf server.
Since a typical Celf application comprises several files, Emacs
maintains a configuration in a file, usally called sources.cfg.  This
file contains a list of files, each on a separate line, in dependency
order.  The `%' character starts a comment line.  A configuration is
established with the command \\[celf-server-configure].

A new file is switched to Celf mode if a file has extension `.elf',
`.quy', `.thm' or `.cfg' and the `auto-mode-alist' is set correctly (see
init.el).

The files in the current configuration can be checked in sequence with
\\[celf-save-check-config] or
\\[celf-save-append-config], the current file with
\\[celf-save-check-file], individual declarations with
\\[celf-check-declaration].  These, like many other commands, take an
optional prefix arguments which means to display the Celf server buffer
after the processing of the configuration, file, or declaration.  If an
error should arise during these or related operations a message is
issued both in the server buffer and Emacs, and the command
\\[celf-next-error] visits the presumed source of the type error in a
separate buffer.

Summary of most common commands:
 M-x celf-save-check-config \\[celf-save-check-config]  save, check & load configuration
 M-x celf-save-append-config \\[celf-save-append-config]  save, check & load configuration without resetting or reloading unmodified files
 M-x celf-save-check-file   \\[celf-save-check-file]  save, check & load current file
 M-x celf-check-declaration \\[celf-check-declaration]  type-check declaration at point
 M-x celf-server-display    \\[celf-server-display]  display Celf server buffer

It is important to remember that the commands to save and check
a file or check a declaration may change the state of the global
signature maintained in Celf.  After a number of changes it is usually
a good idea to return to a clean slate with \\[celf-save-check-config].

Individual Commands
===================

Configurations, Files and Declarations

  celf-save-check-config                   \\[celf-save-check-config]
   Save its modified buffers and then check the current Celf configuration.
   With prefix argument also displays Celf server buffer.
   If necessary, this will start up an Celf server process.

  celf-save-append-config                  \\[celf-save-append-config]
   Save its modified buffers and then check the current Celf configuration
   without resetting or reloading files unmodified since the last check.
   With prefix argument also displays Celf server buffer.
   If necessary, this will start up an Celf server process.

  celf-save-check-file                     \\[celf-save-check-file]
   Save buffer and then check it by giving a command to the Celf server.
   With prefix argument also displays Celf server buffer.

  celf-check-declaration                   \\[celf-check-declaration]
   Send the current declaration to the Celf server process for checking.
   With prefix argument, subsequently display Celf server buffer.

Subterm at Point

  celf-type-const                          \\[celf-type-const]
   Display the type of the constant before point.
   Note that the type of the constant will be `absolute' rather than the
   type of the particular instance of the constant.

Error Tracking

  celf-next-error                          \\[celf-next-error]
   Find the next error by parsing the Celf server or Celf-SML buffer.

  celf-goto-error                          \\[celf-goto-error]
   Go to the error reported on the current line or below.

Server State

  celf-set PARM VALUE                      \\[celf-set]
   Sets the Celf server parameter PARM to VALUE.
   Prompts for PARM when called interactively, using completion for legal
   parameters.

  celf-get PARM                            \\[celf-get]
   Print the current value the Celf server parameter PARM.

  celf-server-interrupt                    \\[celf-server-interrupt]
   Interrupt the Celf server-process.

  celf-server                              \\[celf-server]
   Start a Celf server process in a buffer named *celf-server*.

  celf-server-configure                    \\[celf-server-configure]
   Set the current configuration of the Celf server.

  celf-reset                               \\[celf-reset]
   Reset the global signature in the Celf server process.

  celf-server-quit                         \\[celf-server-quit]
   Kill the Celf server process.

  celf-server-restart                      \\[celf-server-restart]
   Restarts server and re-initializes configuration.
   This is primarily useful during debugging of the Celf server code or
   if the Celf server is hopelessly wedged.

  celf-server-send-command                 \\[celf-server-send-command]
   Send arbitrary string to Celf server.

Tags (for other, M-x apropos tags or see `etags' documentation)

  celf-tag                                 \\[celf-tag]
   Create tags file TAGS for current configuration.
   If current configuration is names CONFIGx, tags file will be named TAGx.
   Errors are displayed in the Celf server buffer.

Timers

  celf-timers-reset			    \\[celf-timers-reset]
   Reset Celf timers.

  celf-timers-show                         \\[celf-timers-show]
   Show and reset Celf timers.

  celf-timers-check                        \\[celf-timers-check]
   Show, but do not reset Celf timers.

Editing

  celf-indent-decl                         \\[celf-indent-decl]
   Indent each line in current declaration as Celf code.

  celf-indent-region                       \\[celf-indent-region]
   Indent each line of the region as Celf code.

Minor Modes
===========

An associated minor modes is 2Celf-SML (toggled with
celf-to-celf-sml-mode).  This means that we assume communication
is an inferior Celf-SML process and not a Celf server.

Related Major Modes
===================

Related major modes are Celf Server (for the Celf server buffer) and
Celf-SML (for an inferior Celf-SML process).  Both modes are based on
the standard Emacs comint package and inherit keybindings for retrieving
preceding input.

Customization
=============

The following variables may be of general utility.

 celf-indent          amount of indentation for nested Celf expressions
 celf-mode-hook       hook to run when entering Celf mode
 celf-server-program  full pathname of Celf server program
 celf-server-mode-hook  hook to run when entering Celf server mode
 celf-info-file       name of Celf info file with documentation

The following is a typical section of a .emacs initialization file
which can be found in the file init.el.

(setq load-path (cons \"/afs/cs/project/celf/research/celf/emacs\" load-path))

(autoload 'celf-mode \"celf\" \"Major mode for editing Celf source.\" t)
(autoload 'celf-server \"celf\" \"Run an inferior Celf server.\" t)
(autoload 'celf-sml \"celf\" \"Run an inferior Celf-SML process.\" t)

(setq auto-mode-alist
      (cons '(\"\\.elf$\" . celf-mode)
	    (cons '(\"\\.quy$\" . celf-mode)
		  (cons '(\"\\.thm$\" . celf-mode)
			(cons '(\"\\.cfg$\" . celf-mode)
			      auto-mode-alist)))))

(setq celf-server-program
      \"/afs/cs/project/celf/research/celf/bin/celf-server\")

(setq celf-sml-program
      \"/afs/cs/project/celf/misc/smlnj/bin/sml-cm\")

(setq celf-info-file
      \"/afs/cs/project/celf/research/celf/doc/info/celf.info\")
"
  (interactive)
  (kill-all-local-variables)
  (celf-mode-variables)
  (use-local-map celf-mode-map)
  (setq major-mode 'celf-mode)
  (setq mode-name "Celf")
  (celf-config-mode-check)
  (celf-add-menu)			; add Celf menu to menubar
  ;; disable celf-add-to-config-check: require explicit add-file
  ;; (celf-add-to-config-check)
  (run-hooks 'celf-mode-hook))

;;;----------------------------------------------------------------------
;;; Reading info file
;;;----------------------------------------------------------------------

(defun celf-info (&optional file)
  "Enter Info, starting with the Celf node
Optional argument FILE specifies the info file.

In interactive use, a prefix arguments directs this command to
read a file name from the minibuffer."
  (interactive (if current-prefix-arg
		   (list (read-file-name "Info file name: " nil nil t))))
  (info (or file celf-info-file)))

;;;----------------------------------------------------------------------
;;; Error message parsing
;;;----------------------------------------------------------------------

(defconst celf-error-regexp
  "^.+:[-0-9.:]+.* \\(Error\\|Warning\\):"
  "Regexp for matching Celf error.")

(defconst celf-error-fields-regexp
   "^[-=? \t]*\\(.+\\):\
\\([0-9]+\\)\\(\\.\\([0-9]+\\)\\)?\\(-\\([0-9]+\\)\\(\\.\\([0-9]+\\)\\)?\\)?\
.+\\(Error\\|Warning\\):"
   "Regexp to extract fields of Celf error.")

(defconst celf-error-decl-regexp
  "^[-=? \t]*\\(.+\\)::\\([^ \t\n]+\\) "  
  "Regexp to extract filename and identifier from declaration error.")

(defun looked-at-nth (n)
  (let ((b (match-beginning n))
        (e (match-end n)))
    (if (or (null b) (null e)) nil
      (buffer-substring (match-beginning n) (match-end n)))))

(defun looked-at-nth-int (n)
  (let ((str (looked-at-nth n)))
    (if (null str) nil
      (string-to-int str))))

(defun celf-error-parser (pt)
  "Standard parser for Celf errors.
Returns a 5-element list (FILE START-LINE START-COL END-LINE END-COL)
or (\"Local\" START-CHAR NIL END-CHAR NIL)."
  (save-excursion
    (goto-char pt)
    (re-search-forward celf-error-fields-regexp)
    (list (looked-at-nth 1)		; file or "Local" or "stdIn"
          (looked-at-nth-int 2)		; start line or char
          (looked-at-nth-int 4)		; start column, if given, else nil
          (looked-at-nth-int 6)		; end line, if given, else nil or char
          (looked-at-nth-int 8)		; end column, if given, else nil
          )))

(defun celf-error-decl (pos)
  "Determines if the error is identified only by its declaration."
  (save-excursion
    (goto-char pos)
    (looking-at celf-error-decl-regexp)))

(defun celf-mark-relative (line0 col0 line1 col1)
  "Mark error region if location is given relative to a buffer position."
  (if (not (= line0 1))
      (forward-line (1- line0)))
  ;; work around bug: from stdIn, first line is off by one.
  (forward-char (if (not (= line0 1)) (1- col0) (1- (1- col0))))
  ;; select region, if non-empty
  (cond ((not (null line1))
         (push-mark (point))
         (cond ((not (= line1 line0))
                (forward-line (- line1 line0))
                (forward-char (1- col1)))
               (t (forward-char (- col1 col0))))
         (exchange-point-and-mark)
	 (funcall celf-highlight-range-function (point) (mark)))))

(defun celf-mark-absolute (line0 col0 line1 col1)
  "Mark error region if location is given as absolute buffer position."
  (cond ((and line0 col0 line1 col1)	; line0.col0-line1.col1 range
	 (goto-line line0)
	 ;; don't use move-to-column since <tab> is 1 char to lexer
	 (forward-char (1- col0))
	 ;; select region, if non-empty
	 (push-mark (point))
	 (goto-line line1)
	 (forward-char (1- col1))
	 (exchange-point-and-mark)
	 (funcall celf-highlight-range-function (point) (mark)))
	((and (null col0) (null col1))	; char0-char1 range
	 (goto-char line0)
	 (push-mark (point))
	 (goto-char line1)
	 (exchange-point-and-mark)
	 (funcall celf-highlight-range-function (point) (mark)))
	((and line0 col0)		; beginning line0.col0
	 (goto-line line0)
	 (forward-char (1- col0)))
	(line0				; beginning char0
	 (goto-char line0))
	(t (error "Unrecognized format for error location"))))

(defun celf-find-decl (filename id)
  "In FILENAME find probable declaration of ID."
  (if (not (file-readable-p filename))
      (error "Cannot read file %s" filename)
    (switch-to-buffer-other-window (find-file-noselect filename))
    (goto-char (point-min))
    (let ((done nil)
	  decl-id)
      (while (not done)
	(setq decl-id (celf-next-decl filename *celf-last-input-buffer*))
	(if (not decl-id)
	    (error "Declaration of %s not found in file %s." id filename)
	  (setq done (string= decl-id id))
	  (if (not done) (celf-end-of-par)))))))

(defun celf-next-error ()
  "Find the next error by parsing the Celf server or Celf-SML buffer.
Move the error message on the top line of the window;
put the cursor at the beginning of the error source. If the
error message specifies a range, the mark is placed at the end."
  (interactive)
  (let ((case-fold-search nil)
        (celf-buffer (or *celf-last-input-buffer*
                        (error "Cannot determine process buffer with last input")))
	error-begin)
    (pop-to-buffer celf-buffer)
    (goto-char *celf-error-pos*)   ; go to last error
    (if (not (re-search-forward celf-error-regexp (point-max) t))
        (error "No error message found.")
      (setq error-begin (match-beginning 0))
      (setq *celf-error-pos* (point))
      (set-window-start (get-buffer-window celf-buffer)
			(save-excursion (beginning-of-line) (point)))
      (if (celf-error-decl error-begin)
	  (celf-find-decl (looked-at-nth 1) (looked-at-nth 2))
	(let* ((parse (celf-error-parser error-begin))
	       (file (nth 0 parse))
	       (line0 (nth 1 parse))
	       (col0 (nth 2 parse))
	       (line1 (nth 3 parse))
	       (col1 (nth 4 parse)))
	  (cond ((equal file "stdIn")
		 ;; Error came from direct input
		 (cond ((null *celf-last-region-sent*)
			;; from last interactive input in the Celf buffer
			(goto-char (point-max))
			(comint-previous-input 1)
			(setq *celf-last-region-sent* t)
			(goto-char (process-mark
				    (get-buffer-process celf-buffer)))
			(celf-mark-relative line0 col0 line1 col1))
		       ((eq *celf-last-region-sent* t)
			;; from the waiting input in the Celf buffer
			(goto-char (process-mark
				    (get-buffer-process celf-buffer)))
			(celf-mark-relative line0 col0 line1 col1))
		       (t
			;; from a region sent from some buffer
			(let ((buf (nth 0 *celf-last-region-sent*))
			      (start (nth 1 *celf-last-region-sent*)))
			  (switch-to-buffer-other-window buf)
			  (goto-char start)
			  (celf-mark-relative line0 col0 line1 col1)))))
		((equal file "Local")
		 ;; Error came from local input, usually to a server process
		 ;; in this case the address relative, and expressed in
		 ;; characters, rather than lines.
		 (let ((local-buffer (nth 0 *celf-last-region-sent*))
		       ;; Local characters seem to be off by two
		       (char0 (+ (nth 1 *celf-last-region-sent*) (- line0 2)))
		       (char1 (+ (nth 1 *celf-last-region-sent*) (- line1 2))))
		   (switch-to-buffer-other-window local-buffer)
		   (goto-char char1)
		   (push-mark)
		   (goto-char char0)
		   (exchange-point-and-mark)))
		((file-readable-p file)
		 ;; Error came from a source file
		 (switch-to-buffer-other-window (find-file-noselect file))
		 (celf-mark-absolute line0 col0 line1 col1))
		(t
		 (error (concat "Can't read file " file)))))))))

(defun celf-goto-error ()
  "Go to the error reported on the current line or below.
Also updates the error cursor to the current line."
  (interactive)
  (pop-to-buffer (or *celf-last-input-buffer*
                     (error "Cannot determine process buffer with last input")))
  (beginning-of-line)
  (setq *celf-error-pos* (point))
  (celf-next-error))

;;;----------------------------------------------------------------------
;;; NT Emacs bug workaround
;;;----------------------------------------------------------------------

(defun celf-convert-standard-filename (filename)
  "Convert FILENAME to form appropriate for Celf Server of current OS."
  (cond ((eq system-type 'windows-nt)
	 (while (string-match "/" filename)
	   (setq filename (replace-match "\\" t t filename)))
	 filename)
	((eq system-type 'cygwin32)
	 (while (string-match "/" filename)
	   (setq filename (replace-match "\\" t t filename)))
	 (concat "C:\\cygwin\\" filename))
	(t (convert-standard-filename filename))))

;;;----------------------------------------------------------------------
;;; Communication with Celf server
;;;----------------------------------------------------------------------

(defun string-member (x l)
  (if (null l) nil
    (or (string-equal x (car l)) (string-member x (cdr l)))))

;(defun celf-add-to-config-check ()
;  "Ask if current file should be added to the current Celf configuration."
;  (let ((file-name (buffer-file-name)))
;    (if (and (not (string-member file-name *celf-config-list*))
;             (not (null *celf-config-buffer*))
;             (yes-or-no-p "Add to the current configuration? "))
;        (celf-server-add-file file-name))))

(defun celf-config-proceed-p (file-name)
  "Ask if to proceed if FILE-NAME is not in current configuration."
  (if (and (not (string-member file-name *celf-config-list*))
	   (not (yes-or-no-p "File not in current configuration.  Save? ")))
      nil
    t))

(defun celf-save-if-config (buffer)
  "Ask if BUFFER should be saved if in the current configuration.
Always save if the variable `celf-save-silently' is non-nil."
  (let ((file-name (buffer-file-name buffer)))
    (if (and (buffer-modified-p buffer)
	     file-name
	     (string-member file-name *celf-config-list*))
	(if celf-save-silently
	    (save-buffer)
	  (pop-to-buffer buffer)
	  (if (yes-or-no-p (concat "Save " file-name "? "))
	      (save-buffer))))))

(defun celf-config-save-some-buffers ()
  "Cycle through all buffers and save those in the current configuration."
  (mapcar 'celf-save-if-config (buffer-list)))

(defun celf-save-check-config (&optional displayp)
  "Save its modified buffers and then check the current Celf configuration.
With prefix argument also displays Celf server buffer.
If necessary, this will start up an Celf server process."
  (interactive "P")
  (celf-save-op-config 'celf-check-config displayp))

(defun celf-save-append-config (&optional displayp)
  "Save its modified buffers and then check the current Celf configuration
without resetting or reloading files unmodified since the last check.
With prefix argument also displays Celf server buffer.
If necessary, this will start up an Celf server process."
  (interactive "P")
  (celf-save-op-config 'celf-append-config displayp))

(defun celf-save-op-config (celf-op-config &optional displayp)
  "Save its modified buffers and then `celf-op-config' the current
Celf configuration.  With prefix argument also displays Celf server
buffer.  If necessary, this will start up an Celf server process."
  (let ((current-file-name (buffer-file-name)))
    (cond ((and current-file-name
		(not buffer-read-only)
		(buffer-modified-p)
		(celf-config-proceed-p current-file-name))
	   (save-buffer)))
    (save-excursion
      (celf-config-save-some-buffers))
    (funcall celf-op-config displayp)))

(defun celf-with-batch-chatter (batch-op)
  "Run batch-op with the chatter level set to \\[celf-batch-chatter].
Restores the chatter level to \\[celf-chatter] upon completion."
  (celf-server-send-command (concat "set chatter " celf-batch-chatter) t)
  (celf-server-wait nil 'silent)
  (unwind-protect
      (funcall batch-op)
    (celf-server-send-command (concat "set chatter " celf-chatter) t)
    (celf-server-wait nil 'silent)))

(defun celf-check-config (&optional displayp)
  "Check the current Celf configuration.
With prefix argument also displays Celf server buffer.
If necessary, this will start up an Celf server process."
  (interactive "P")
  (if (not *celf-config-buffer*)
      (call-interactively 'celf-server-configure))
  (when celf-check-config-clears-server-buffer
    (celf-clear-server-buffer)
    (celf-server-send-command "version")
    (celf-server-wait nil ""))
  (celf-server-sync-config)
  (celf-focus nil nil)
  (celf-with-batch-chatter
   (lambda ()
     (celf-server-send-command "Config.load")
     (celf-server-wait displayp))))

(defun celf-append-config (&optional displayp)
  "Check the current Celf configuration without resetting
or reloading files unmodified since the last check.
With prefix argument also displays Celf server buffer.
If necessary, this will start up an Celf server process."
  (interactive "P")
  (if (not *celf-config-buffer*)
      (call-interactively 'celf-server-configure))
  (celf-server-sync-config)
  (celf-focus nil nil)
  (celf-with-batch-chatter
   (lambda ()
     (celf-server-send-command "Config.append")
     (celf-server-wait displayp))))

(defun celf-save-check-file (&optional displayp)
  "Save buffer and then check it by giving a command to the Celf server.
In Celf Config minor mode, it reconfigures the server.
With prefix argument also displays Celf server buffer."
  (interactive "P")
  (save-buffer)
  (if celf-config-mode
      (celf-server-configure (buffer-file-name) "Server OK: Reconfigured")
    (let* ((save-file (buffer-file-name))
	   (check-file (file-relative-name save-file (celf-config-directory)))
	   (check-file-os (celf-convert-standard-filename check-file)))
      (celf-server-sync-config)
      (celf-focus nil nil)
      (celf-with-batch-chatter
       (lambda ()
	 (celf-server-send-command (concat "loadFile " check-file-os))
	 (celf-server-wait displayp))))))

(defun celf-buffer-substring (start end)
  "The substring of the current buffer between START and END.
The location is recorded for purposes of error parsing."
  (setq *celf-last-region-sent* (list (current-buffer) start end))
  (buffer-substring start end))

(defun celf-buffer-substring-dot (start end)
  "The substring of the current buffer between START and END plus
an end-of-input marker, `%.'.  The location of the input is recorded
for purposes of error parsing."
  (concat (celf-buffer-substring start end) "%."))

(defun celf-check-declaration (&optional displayp)
  "Send the current declaration to the Celf server process for checking.
With prefix argument also displays Celf server buffer."
  (interactive "P")
  (let* ((par (celf-current-decl))
         (par-start (nth 0 par))
         (par-end (nth 1 par))
         (decl (celf-buffer-substring-dot par-start par-end)))
    (celf-focus par-start par-end)
    (celf-server-send-command (concat "readDecl\n" decl))
    (celf-server-wait displayp)))

;(defun celf-highlight-range (par-start par-end &optional offset)
;  "Set point and mark to encompass the range analyzed by the Celf server."
;  (let* ((range (celf-parse-range))
;         (range-start (nth 0 range))
;         (range-end (nth 1 range))
;         (offset (if (null offset) 0 offset)))
;    (if (and (integerp range-start) (integerp range-end))
;        (progn (goto-char (+ (- (+ par-start range-end) 2) offset))
;               (push-mark (- (+ par-start range-start) 2))
;	       (funcall celf-highlight-range-function (point) (mark))))))

(defun celf-highlight-range-zmacs (start end)
  "Highlight range as zmacs region.  Assumes point and mark are set.
Does nothing if function zmacs-activate-region is undefined."
  (if (fboundp 'zmacs-activate-region)
      (zmacs-activate-region)))

(defun celf-focus (&optional start end)
  "Focus on region between START and END as current declaration or query.  If
START and END are nil, then no focus exists.  This intermediary just calls
the appropriate function."
  (funcall celf-focus-function start end))

(defun celf-focus-noop (start end)
  "This default focus function does nothing."
  ())

;; Not yet available in Celf 1.2 -fp

;(defun celf-type-at-point ()
;  "Display the type of the subterm at the point in the current Celf decl.

;The subterm at point is the smallest subterm whose printed representation
;begins to the left of point and extends up to or beyond point.  After this and
;similar commands applicable to subterms, the current region (between mark and
;point) is set to encompass precisely the selected subterm.  In XEmacs,
;it will thus be highlighted under many circumstances.  In other versions
;of Emacs \\[exchange-point-and-mark] will indicate the extent of the region.

;The type computed for the subterm at point takes contextual information into
;account.  For example, if the subterm at point is a constant with implicit
;arguments, the type displayed will be the instance of the constant (unlike
;M-x celf-type-const (\\[celf-type-const]), which yields the absolute type of a constant)."

;  (interactive)
;  (let* ((par (celf-current-decl))
;         (par-start (nth 0 par))
;         (par-end (nth 1 par))
;         (decl (celf-buffer-substring-dot par-start par-end)))
;    (celf-focus par-start par-end)
;    (celf-server-send-command
;     (concat "type-at "
;             (celf-current-syncat) " "
;             (int-to-string (+ (- (point) par-start) 2)) "\n"
;             decl))
;    (celf-server-wait t)
;    (celf-highlight-range par-start par-end)))

;(defun celf-expected-type-at-point ()
;  "Display the type expected at the point in the current declaration.

;This replaces the subterm at point by an underscore _ and determines
;the type that _ would have to have for the whole declaration to be valid.
;This is useful for debugging in places where inconsistent type constraints
;have arisen.  Error messages may be given, but will not be correctly
;interpreted by Emacs, since the string sent to the server may be different
;from the declaration in the buffer.

;For a definition of the subterm at point, see function celf-type-at-point."
;  (interactive)
;  (let* ((par (celf-current-decl))
;         (par-start (nth 0 par))
;         (par-end (nth 1 par))
;         (par-initial-end nil)
;         (par-final-start nil)
;         modified-decl)
;    ;; (exp-present (not (looking-at (concat "[" *whitespace* "]"))))
;    (backward-sexp 1)
;    (setq par-initial-end (point))
;    (forward-sexp 1)
;    (setq par-final-start (point))
;    (setq modified-decl
;          (concat (celf-buffer-substring par-start par-initial-end)
;                  "_" (celf-buffer-substring-dot par-final-start par-end)))
;    ;; Error messages here are not accurate.  Nontheless:
;    (setq *celf-last-region-sent* (list (current-buffer) par-start par-end))
;    (celf-focus par-start par-end)
;    (celf-server-send-command
;     (concat "type-at "
;             (celf-current-syncat) " "
;             (int-to-string (1+ (+ (- par-initial-end par-start) 2))) "\n"
;             modified-decl))
;    (celf-server-wait t)
;    (celf-highlight-range par-start par-end
;			 (1- (- par-final-start par-initial-end)))))

;(defun celf-parse-range ()
;  "Parse a range as returned by the Celf server and return as a list."
;  (save-window-excursion
;    (let ((celf-server-buffer (celf-get-server-buffer)))
;      (set-buffer celf-server-buffer)
;      (goto-char *celf-server-last-process-mark*)
;      ;; We are now at the beginning of the output
;      (re-search-forward "^\\[\\([0-9]+\\),\\([0-9]+\\))")
;      (list (looked-at-nth-int 1) (looked-at-nth-int 2)))))

(defun celf-type-const ()
  "Display the type of the constant before point.
Note that the type of the constant will be `absolute' rather than the
type of the particular instance of the constant."
  (interactive)
  (let ((previous-point (point)))
    (skip-chars-backward *whitespace* (point-min))
    (skip-chars-forward *celf-id-chars* (point-max))
    (let ((end-of-id (point)))
      (skip-chars-backward *celf-id-chars* (point-min))
      (let ((c (if (= (point) end-of-id)
                   ;; we didn't move.  this should eventually become a
                   ;; completing-read
                   (read-string "Constant: ")
                 (buffer-substring (point) end-of-id))))
        (celf-server-send-command (concat "decl " c))
        (celf-server-wait t)             ; Wait for and display reply
        (goto-char previous-point)))))

;; Unused? -fp
;(defun celf-backwards-parse-arglist ()
;  "Parse an argument list template as returned by the server."
;  (save-window-excursion
;    (let ((celf-server-buffer (celf-get-server-buffer)))
;      (set-buffer celf-server-buffer)
;      (goto-char *celf-server-last-process-mark*)
;      ;; Should be right at the beginning of the output.
;      ;; (re-search-forward "^arglist") ; 
;      ;; (beginning-of-line 2)
;      (let ((arglist-begin (point)))
;        (skip-chars-forward "^." (point-max))
;        (buffer-substring arglist-begin (point))))))

;; Not yet ported to Celf 1.2
;(defun celf-show-region-in-window (start end)
;  "Change window parameters so it precisely shows the given region."
;  (enlarge-window (- (max (count-lines start end) window-min-height)
;                     (window-height)))
;  (set-window-start (selected-window) start))

;(defun celf-show-menu ()
;  "Display the Celf server buffer to show menu of possible completions."
;  (let ((old-buffer (current-buffer))
;        (celf-server-buffer (celf-get-server-buffer))
;        region-start region-end)
;    (switch-to-buffer-other-window celf-server-buffer)
;    (goto-char *celf-server-last-process-mark*)
;    (if (re-search-forward "-\\.$" (point-max) t)
;        (progn
;          (forward-char 1)
;          (setq region-start (point))
;          (if (re-search-forward "^-\\." (point-max) t)
;              (setq region-end (point))
;            (error "List of alternatives not terminated by -.")))
;      (error "No alternatives found."))
;    (celf-show-region-in-window region-start region-end)
;    (switch-to-buffer-other-window old-buffer)))

;(defun celf-completions-at-point ()
;  "List the possible completions of the term at point based on type information.

;The possible completions are numbered, and the function celf-complete
;(\\[celf-complete]) can be used subsequently to replace the term at point with
;one of the alternatives.

;Above the display of the alternatives, the type of the subterm at
;point is shown, since it is this type which is the basis for listing
;the possible completions.

;In the list alternatives, a variable X free in the remaining declaration
;is printed ^X, and a bound variable x may be printed as !x.  These marks
;are intended to aid in the understanding of the alternatives, but
;must be removed in case the alternative is copied literally into the
;input declaration (as, for example, with the \\[celf-complete] command)."
;  (interactive)
;  (let* ((par (celf-current-decl))
;         (par-start (nth 0 par))
;         (par-end (nth 1 par))
;         (decl (celf-buffer-substring-dot par-start par-end)))
;    (celf-focus par-start par-end)
;    (celf-server-send-command
;     (concat "complete-at "
;             (celf-current-syncat) " "
;             (int-to-string (+ (- (point) par-start) 2)) "\n"
;             decl))
;    (celf-server-wait nil)
;    (celf-highlight-range par-start par-end)
;    (celf-show-menu)))

;(defun celf-complete (n)
;  "Pick the alternative N from among possible completions.
;This replaces the current region with the given pattern.
;The list of completions must be generated with the command
;celf-completions-at-point (\\[celf-completions-at-point])."
;  (interactive "NAlternative: ")
;  (let (start completion)
;    (save-excursion
;      (set-buffer (celf-get-server-buffer))
;      (goto-char *celf-server-last-process-mark*)
;      (if (not (re-search-forward (concat "^" (int-to-string n) "\\. ")
;                                  (point-max) t))
;          (error "No alternative %d found in Celf server buffer." n))
;      (setq start (point))
;      (if (not (search-forward " ::" (point-max) t))
;          (error "List of completions not well-formed."))
;      (backward-char 3)
;      (setq completion (buffer-substring start (point))))
;    (delete-region (point) (mark))
;    (insert "(" completion ")")
;    (celf-show-menu)))

;;;----------------------------------------------------------------------
;;; Celf server mode (major mode)
;;; This is for the buffer with the Celf server process, to facilitate
;;; direct interaction (which should rarely be necessary)
;;;----------------------------------------------------------------------

(defvar celf-server-mode-map nil
  "The keymap used in celf-server mode.")

(cond ((not celf-server-mode-map)
       (setq celf-server-mode-map (copy-keymap comint-mode-map))
       (install-basic-celf-keybindings celf-server-mode-map)
       ;; C-c C-c is bound to celf-save-check config in Celf mode
       (define-key celf-server-mode-map "\C-c\C-c" 'celf-save-check-config)
       ;; Bind the function shadowed by the previous definition to C-c C-i
       (define-key celf-server-mode-map "\C-c\C-i" 'comint-interrupt-subjob)
       ))

(defconst celf-server-cd-regexp "^\\s *OS\\.chDir\\s *\\(.*\\)"
  "Regular expression used to match cd commands in Celf server buffer.")

(defun looked-at-string (string n)
  "Substring of STRING consisting of Nth match."
  (substring string (match-beginning n) (match-end n)))

(defun celf-server-directory-tracker (input)
  "Checks input for cd commands and changes default directory in buffer.
As a side effect, it resets *celf-error-pos* and *celf-last-region-sent*
to indicate interactive input.  Used as comint-input-filter-function in Celf
server buffer."
  (if (celf-input-filter input)
      (setq *celf-last-region-sent* nil))
  (setq *celf-last-input-buffer* (current-buffer))
  (setq *celf-error-pos* (marker-position (process-mark (celf-server-process))))
  (cond ((string-match celf-server-cd-regexp input)
         (let ((expanded-dir (expand-dir (looked-at-string input 1))))
           (setq default-directory expanded-dir)
           (pwd)))
	;;((string-match "^set\\s +chatter\\s +\\([0-9]\\)+" input)
	;;  (setq celf-chatter (string-to-int (looked-at-string input 1))))
	;; ((string-match "^set\\s +Trace\\.detail\\s +\\([0-9]\\)+" input)
	;; (setq celf-trace-detail (string-to-int (looked-at-string input 1))))
	((string-match "^set\\s-+\\(\\S-+\\)\\s-+\\(\\w+\\)" input)
	 (if (assoc (looked-at-string input 1) *celf-track-parms*)
	     (set (cdr (assoc (looked-at-string input 1) *celf-track-parms*))
		  (looked-at-string input 2))))))

(defun celf-input-filter (input)
  "Function to filter strings before they are saved in input history.
We filter out all whitespace and anything shorter than two characters."
  (and (not (string-match "\\`\\s *\\'" input))
       (> (length input) 1)))

(defun celf-server-mode ()
  "Major mode for interacting with an inferior Celf server process.
Runs celf-server-mode-hook.

The following commands are available:
\\{celf-server-mode-map}"
  (interactive)
  (kill-all-local-variables)
  ;; Initialize comint parameters
  (comint-mode)
  (setq comint-prompt-regexp "^") ;; no prompt
  (setq comint-input-filter 'celf-input-filter)
  ;;changed for XEmacs 19.16
  ;;(setq comint-input-sentinel 'celf-server-directory-tracker)
  (add-hook 'comint-input-filter-functions 'celf-server-directory-tracker
	    nil t)
  (celf-mode-variables)
  ;; For sequencing through error messages:
  (make-local-variable '*celf-error-pos*)
  (setq *celf-error-pos* (point-max))
  ;; Set mode and keymap
  (setq major-mode 'celf-server-mode)
  (setq mode-name "Celf Server")
  (setq mode-line-process '(": %s"))
  (use-local-map celf-server-mode-map)
  (celf-server-add-menu)		; add Celf Server menu
  ;; Run user specified hooks, if any
  (run-hooks 'celf-server-mode-hook))

;;;----------------------------------------------------------------------
;;; Functions to support use of the Celf server
;;;----------------------------------------------------------------------

(defun celf-parse-config ()
  "Starting at point, parse a configuration file."
  (let ((filelist nil))
    (skip-chars-forward *whitespace*)
    (while (not (eobp))                 ; end of buffer?
      (cond ((looking-at "%")           ; comment through end of line
             (end-of-line))
            (t (let ((begin-point (point))) ; parse filename starting at point
                 (skip-chars-forward (concat "^" *whitespace*))
                 (let* ((file-name (buffer-substring begin-point (point)))
                        (absolute-file-name
                         (expand-file-name file-name default-directory)))
                   (if (file-readable-p absolute-file-name)
                       (setq filelist (cons absolute-file-name filelist))
                     (error "File %s not readable." file-name))))))
      (skip-chars-forward *whitespace*))
    filelist))

(defun celf-server-read-config ()
  "Read the configuration and initialize *celf-config-list*."
  (if (or (not (bufferp *celf-config-buffer*))
          (null (buffer-name *celf-config-buffer*)))
      (error "No current configuration buffer"))
  (set-buffer *celf-config-buffer*)
  (goto-char (point-min))
  (celf-parse-config))

(defun celf-server-sync-config ()
  "Synchronize the configuration file, buffer, and Celf server."
  (if (or (not (bufferp *celf-config-buffer*))
          (null (buffer-name *celf-config-buffer*)))
      (error "No current configuration buffer"))
  (if (and celf-config-mode
	   (not (equal *celf-config-buffer* (current-buffer)))
	   (yes-or-no-p "Buffer is different from current configuration, reconfigure server? "))
      (celf-server-configure (buffer-file-name (current-buffer))
			      "Server OK: Reconfigured"))
  (save-excursion
    (set-buffer *celf-config-buffer*)
    (if (buffer-modified-p *celf-config-buffer*)
        (progn
          (display-buffer *celf-config-buffer*)
          (if (yes-or-no-p "Config buffer has changed, save new version? ")
              (save-buffer)
            (message "Checking old configuration"))))
    (if (not (verify-visited-file-modtime *celf-config-buffer*))
        (if (yes-or-no-p "Config file has changed, read new contents? ")
            (revert-buffer t t)))
    (if (not (equal (visited-file-modtime) *celf-config-time*))
        (progn 
          (display-buffer *celf-config-buffer*)
          (if (yes-or-no-p "Config file has changed, reconfigure server? ")
              (celf-server-configure (buffer-file-name *celf-config-buffer*)
                                    "Server OK: Configured")
            (if (not (yes-or-no-p "Ask next time? "))
                (setq *celf-config-time* (visited-file-modtime))))))))

(defun celf-get-server-buffer (&optional createp)
  "Get the current Celf server buffer.
Optional argument CREATEP indicates if the buffer should be
created if it doesn't exist."
  (if (and (bufferp *celf-server-buffer*)
           (not (null (buffer-name *celf-server-buffer*))))
      *celf-server-buffer*
    (if createp
        (let ((celf-server-buffer
               (get-buffer-create *celf-server-buffer-name*)))
          (save-window-excursion
            (set-buffer celf-server-buffer)
	    (buffer-disable-undo)
            (celf-server-mode)
            (setq *celf-server-buffer* celf-server-buffer))
          celf-server-buffer)
      (error "No Celf server buffer"))))

(defun celf-clear-server-buffer ()
  "Clear the server buffer."
  (let ((celf-server-buffer (celf-get-server-buffer)))
    (save-window-excursion
      (set-buffer celf-server-buffer)
      (erase-buffer))))

(defun celf-init-variables ()
  "Initialize variables that track Celf server state."
  (setq celf-chatter "3")
  (setq celf-double-check "false")
  (setq celf-unsafe "false")
  (setq celf-auto-freeze "true")
  (setq celf-print-implicit "false")
  (setq celf-trace-detail "1")
  (setq celf-compile-optimize "true"))

(defun celf-server (&optional program)
  "Start an Celf server process in a buffer named *celf-server*.
Any previously existing process is deleted after confirmation.
Optional argument PROGRAM defaults to the value of the variable
celf-server-program.
This locally re-binds `celf-server-timeout' to 15 secs."
  (interactive)
  (let* ((default-program (if (null program) celf-server-program program))
         (default-dir (file-name-directory default-program))
         (program (expand-file-name
                   (if (null program)
                       (read-file-name (concat "Celf server: (default "
                                               (file-name-nondirectory
                                                default-program)
                                               ") ")
                                       default-dir
                                       default-program
                                       t)
                     program)))
	 ;; longer timeout during startup
	 (celf-server-timeout 15))
    ;; We save the program name as the default for the next time a server is
    ;; started in this session.
    (setq celf-server-program program))
  (save-window-excursion
    (let* ((celf-server-buffer (celf-get-server-buffer t))
           (celf-server-process (get-buffer-process celf-server-buffer)))
      (set-buffer celf-server-buffer)
      (if (not (null celf-server-process))
          (if (yes-or-no-p "Kill current server process? ")
              (delete-process celf-server-process)
            (error "Celf Server restart aborted")))
      (goto-char (point-max))
      (setq *celf-server-last-process-mark* (point))
      ;; initialize variables
      (celf-init-variables)
      (start-process *celf-server-process-name*
		     celf-server-buffer
		     celf-server-program)
      (celf-server-wait nil)
      (celf-server-process))))

(defun celf-server-process (&optional buffer)
  "Return the celf server process, starting one if none exists."
  (let* ((celf-server-buffer (if (null buffer) (celf-get-server-buffer t)
                              buffer))
         (celf-server-process (get-buffer-process celf-server-buffer)))
      (if (not (null celf-server-process))
          celf-server-process
          (celf-server))))

(defun celf-server-display (&optional selectp)
  "Display Celf server buffer, moving to the end of output.
With prefix argument also selects the Celf server buffer."
  (interactive "P")
  (display-server-buffer)
  (if selectp (pop-to-buffer (celf-get-server-buffer))))

(defun display-server-buffer (&optional buffer)
  "Display the Celf server buffer so that the end of output is visible."
  (let* ((celf-server-buffer (if (null buffer) (celf-get-server-buffer)
                              buffer))
         (_ (set-buffer celf-server-buffer))
         (celf-server-process (celf-server-process celf-server-buffer))
         (proc-mark (process-mark celf-server-process))
         (_ (display-buffer celf-server-buffer))
         (celf-server-window (get-buffer-window celf-server-buffer)))
    (if (not (pos-visible-in-window-p proc-mark celf-server-window))
        (progn
          (push-mark proc-mark)
          (set-window-point celf-server-window proc-mark)))
    (sit-for 0)))

(defun celf-server-send-command (command &optional cantfail)
  "Send a string COMMAND to the Celf server.
If optional argument cantfail is non-nil, suppress the usual behavior of
resetting `*celf-error-pos*'."
  (interactive "sCommand: ")
  (let* ((input (concat command "\n"))
         (celf-server-buffer (celf-get-server-buffer))
         (celf-server-process (celf-server-process celf-server-buffer)))
    (if celf-server-echo-commands
        (let ((previous-buffer (current-buffer)))
          (if celf-server-display-commands
              (display-server-buffer celf-server-buffer))
          (set-buffer celf-server-buffer)
          (goto-char (point-max))
          (insert input)
          (set-marker (process-mark celf-server-process) (point-max))
          (when (not cantfail)
            (setq *celf-error-pos* (point-max)))
          (set-buffer previous-buffer)))
    (setq *celf-last-input-buffer* celf-server-buffer)
    (setq *celf-server-last-process-mark*
          (marker-position (process-mark celf-server-process)))
    (comint-send-string celf-server-process input)))

(defun celf-accept-process-output (process timeout)
  "Incompatibility workaround for versions of accept-process-output.
In case the function accepts no TIMEOUT argument, we wait potentially
forever (until the user aborts, typically with \\[keyboard-quit])."
  (condition-case nil			; do not keep track of error message
      (accept-process-output process timeout)
    (wrong-number-of-arguments
     (accept-process-output process))))

(defun celf-server-wait (&optional displayp ok-message abort-message)
  "Wait for server acknowledgment and beep if error occurred.
If optional argument DISPLAYP is T, or if an error occurred, the
Celf server buffer is displayed.  If DISPLAYP is neither NIL nor T
the Celf server buffer is selected.  Optional second and third arguments
OK-MESSAGE and ABORT-MESSAGE are the strings to show upon successful
completion or abort of the server which default to \"Server OK\" and
\"Server ABORT\".  If OK-MESSAGE is the symbol `silent', the minibuffer
is unaltered on successful completion."
  (if (or (eq displayp 'nil) (eq displayp 't))
      (let* ((chunk-count 0)
	     (last-point *celf-server-last-process-mark*)
	     (previous-match-data (match-data))
	     (selectp (not (equal displayp t)))
	     (celf-server-buffer (celf-get-server-buffer))
	     (celf-server-process (get-buffer-process celf-server-buffer))
	     (previous-buffer (current-buffer)))
	(unwind-protect
	    (catch 'done
	      (set-buffer celf-server-buffer)
	      (while t
		(goto-char last-point)
		(if (re-search-forward "\\(%% OK %%\n\\)\\|\\(%% ABORT %%\n\\)"
				       (point-max) 'limit)
		    (cond ((match-beginning 1)
			   (if displayp
			       (display-server-buffer celf-server-buffer))
			   (when (not (eq ok-message 'silent))
			     (message (or ok-message "Server OK")))
			   (throw 'done nil))
			  ((match-beginning 2)
			   (display-server-buffer celf-server-buffer)
			   (error (or abort-message "Server ABORT"))
			   (throw 'done nil)))
		  (cond ((or (not (celf-accept-process-output
				   celf-server-process celf-server-timeout))
			     (= last-point (point)))
			 (display-server-buffer celf-server-buffer)
			 (message "Server TIMEOUT, continuing Emacs")
			 (throw 'done nil))
			(t (setq chunk-count (+ chunk-count 1))
			   (if (= (mod chunk-count 10) 0)
			       (message (make-string (/ chunk-count 10) ?#)))
			   (sit-for 0))))))
	  (store-match-data previous-match-data)
	  (set-buffer previous-buffer)))
    (celf-server-display t)))

(defun celf-server-quit ()
  "Kill the Celf server process."
  (interactive)
  (celf-server-send-command "OS.exit"))

(defun celf-server-interrupt ()
  "Interrupt the Celf server process."
  (interactive)
  (interrupt-process (celf-server-process)))

(defun celf-reset ()
  "Reset the global signature of Celf maintained by the server."
  (interactive)
  (celf-server-send-command "reset"))

(defun celf-config-directory ()
  "Returns directory with current Celf server configuration."
  (let ((config-file (buffer-file-name *celf-config-buffer*)))
    (file-name-directory config-file)))

;(defun relativize-file-name (filename dir)
;  "Relativize FILENAME with respect to DIR, if possible."
;  (if (string= dir (file-name-directory filename))
;      (file-name-nondirectory filename)
;    filename))

(defun celf-server-configure (config-file &optional ok-message)
  "Initializes the Celf server configuration from CONFIG-FILE.
A configuration file is a list of relative file names in
dependency order.  Lines starting with % are treated as comments.
Starts a Celf servers if necessary."
  (interactive
   (list (if celf-config-mode (buffer-file-name)
	   (expand-file-name
	    (read-file-name "Visit config file: (default sources.cfg) "
			    default-directory
			    (concat default-directory "sources.cfg")
			    nil ; don't require match for now
			    )))))
  (let* ((config-file (if (file-directory-p config-file)
                          (concat config-file "sources.cfg")
                        config-file))
	 (config-file-os (celf-convert-standard-filename config-file))
         (config-dir (file-name-directory config-file))
	 (config-dir-os (celf-convert-standard-filename config-dir))
         (config-buffer (set-buffer (or (get-file-buffer config-file)
                                        (find-file-noselect config-file))))
         config-list)
    (setq *celf-config-buffer* config-buffer)
    (if (and (not (verify-visited-file-modtime (get-file-buffer config-file)))
             (yes-or-no-p "Config file has changed, read new contents? "))
        (revert-buffer t t))
    (setq config-list (celf-server-read-config))
    (celf-server-process)                ; Start process if necessary
    (let* ((_ (set-buffer (celf-get-server-buffer)))
           (cd-command
            (if (equal default-directory config-dir)
                nil
              (setq default-directory config-dir)
              (concat "OS.chDir " config-dir-os)))
           (_ (set-buffer config-buffer)))
      (cond ((not (null cd-command))
	     (celf-server-send-command cd-command)
	     (celf-server-wait nil ""
				"Server ABORT: Could not change directory")))
      (celf-server-send-command
       (concat "Config.read " config-file-os))
      (celf-server-wait nil (or ok-message "Server OK")
                       "Server ABORT: Could not be configured")
      ;; *celf-config-buffer* should still be current buffer here
      (setq *celf-config-time* (visited-file-modtime))
      (setq *celf-config-list* config-list))))

;(defun celf-server-add-file (filename)
;  "Adds a file to the current configuration."
;  (interactive
;   (list (expand-file-name
;          (read-file-name "File to add: " (celf-config-directory)))))
;  (let ((relative-file (file-relative-name filename (celf-config-directory)))
;	temp-time)
;    (save-excursion
;      (set-buffer *celf-config-buffer*)
;      (goto-char (point-max))
;      (if (not (= (point) (point-min)))
;          (progn
;            (backward-char 1)
;            (if (looking-at "\n")
;                (forward-char 1)
;              (forward-char 1)
;              (insert "\n"))))
;      (insert (concat relative-file "\n"))
;      (save-buffer)
;      (setq temp-time (visited-file-modtime)))
;    (celf-server-send-command
;     (concat "Config.read " (buffer-file-name *celf-config-buffer*)))
;    (celf-server-wait nil "" "Server ABORT: File could not be added to configuration")
;    (setq *celf-config-list* (cons filename *celf-config-list*))
;    (setq *celf-config-time* temp-time)))

(defun natp (x)
  "Checks if X is an integer greater or equal to 0."
  (and (integerp x) (>= x 0)))

(defun celf-read-nat ()
  "Reads a natural number from the minibuffer."
  (let ((num nil))
    (while (not (natp num))
      (setq num (read-from-minibuffer "Number: " (if num (prin1-to-string num))
				      nil t t))
      (if (not (natp num)) (beep)))
    (int-to-string num)))

(defun celf-read-bool ()
  "Read a boolean in mini-buffer."
  (completing-read "Boolean: "
		   '(("true" . "true") ("false" . "false"))
		   nil t))

(defun celf-read-limit ()
  "Read a limit (* or natural number) in mini-buffer."
  (let ((input (read-string "Limit (* or nat): ")))
    (if (equal input "*")
	input
      (let ((n (string-to-int input)))
	(if (and (integerp n) (> n 0))
	    (int-to-string n)
	  (error "Number must be non-negative integer"))))))

(defun celf-read-strategy ()
  "Read a strategy in mini-buffer."
  (completing-read "Strategy: "
		   '(("FRS" . "FRS") ("RFS" . "RFS"))
		   nil t))

(defun celf-read-tablestrategy ()
  "Read a tabling strategy in mini-buffer."
  (completing-read "Tabling strategy: "
		   '(("Variant" . "Variant") ("Subsumption" . "Subsumption"))
		   nil t))

(defun celf-read-tracemode ()
  "Read a tracing mode for term reconstruction in mini-buffer."
  (completing-read "Trace mode: "
		   '(("Omniscient" . "Omniscient")
		     ("Progressive" . "Progressive"))
		   nil t))

(defun celf-read-value (argtype)
  "Call the read function appropriate for ARGTYPE and return result."
  (funcall (cdr (assoc argtype *celf-read-functions*))))

(defun celf-set (parm value)
  "Sets the Celf parameter PARM to VALUE.
When called interactively, prompts for parameter and value, supporting
completion."
  (interactive
   (let* ((parm (completing-read 
		 "Parameter: " *celf-parm-table* nil t))
	  (argtype (cdr (assoc parm *celf-parm-table*)))
	  (value (celf-read-value argtype)))
     (list parm value)))
  (track-parm parm value)		; track, if necessary
  (celf-server-send-command (concat "set " parm " " value)))

(defun celf-set-parm (parm)
  "Prompts for and set the value of Celf parameter PARM.
Used in menus."
  (let* ((argtype (cdr (assoc parm *celf-parm-table*)))
	 (value (and argtype (celf-read-value argtype))))
    (if (null argtype)
	(error "Unknown parameter")
      (celf-set parm value))))

(defun track-parm (parm value)
  "Tracks Celf parameter values in Emacs."
  (if (assoc parm *celf-track-parms*)
      (set (cdr (assoc parm *celf-track-parms*)) value)))

(defun celf-toggle-double-check ()
  "Toggles doubleCheck parameter of Celf."
  (let ((value (if (string-equal celf-double-check "false")
		   "true" "false")))
    (celf-set "doubleCheck" value)))

(defun celf-toggle-unsafe ()
  "Toggles unsafe parameter of Celf."
  (let ((value (if (string-equal celf-unsafe "false")
		   "true" "false")))
    (celf-set "unsafe" value)))

(defun celf-toggle-auto-freeze ()
  "Toggles autoFreeze parameter of Celf."
  (let ((value (if (string-equal celf-unsafe "false")
		   "true" "false")))
    (celf-set "autoFreeze" value)))

(defun celf-toggle-print-implicit ()
  "Toggles Print.implicit parameter of Celf."
  (let ((value (if (string-equal celf-print-implicit "false")
		   "true" "false")))
    (celf-set "Print.implicit" value)))

(defun celf-toggle-compile-optimize ()
  "Toggles Compile.optimize parameter of Celf."
  (let ((value (if (string-equal celf-compile-optimize "false")
		   "true" "false")))
    (celf-set "Compile.optimize" value)))

(defun celf-toggle-recon-trace ()
  "Toggles Recon.trace parameter of Celf."
  (let ((value (if (string-equal celf-recon-trace "false")
		   "true" "false")))
    (celf-set "celf-recon-trace" value)))

(defun celf-get (parm)
  "Prints the value of the Celf parameter PARM.
When called interactively, promts for parameter, supporting completion."
  (interactive (list (completing-read "Parameter: " *celf-parm-table* nil t)))
  (celf-server-send-command (concat "get " parm))
  (celf-server-wait nil)
  (save-window-excursion
    (let ((celf-server-buffer (celf-get-server-buffer)))
      (set-buffer celf-server-buffer)
      (goto-char *celf-server-last-process-mark*)
      ;; We are now at the beginning of the output
      (end-of-line 1)
      (message (buffer-substring *celf-server-last-process-mark* (point))))))

(defun celf-print-signature ()
  "Prints the current signature in the Celf server buffer."
  (interactive)
  (celf-server-send-command "Print.sgn")
  (celf-server-display t))

(defun celf-print-program ()
  "Prints the current signature as a program in the Celf server buffer."
  (interactive)
  (celf-server-send-command "Print.prog")
  (celf-server-display t))

(defun celf-print-subordination ()
  "Prints the current subordination relation in the Celf server buffer."
  (interactive)
  (celf-server-send-command "Print.subord")
  (celf-server-display t))

(defun celf-print-domains ()
  "Prints the availalbe constraint domains in the Celf server buffer."
  (interactive)
  (celf-server-send-command "Print.domains")
  (celf-server-display t))

(defun celf-print-tex-signature ()
  "Prints the current signature in TeX style.
The output appears in the  Celf server buffer."
  (interactive)
  (celf-server-send-command "Print.TeX.sgn")
  (celf-server-display t))

(defun celf-print-tex-program ()
  "Prints the current signature as a program in TeX style.
The output appears in the Celf server buffer."
  (interactive)
  (celf-server-send-command "Print.TeX.prog")
  (celf-server-display t))

(defun celf-read-constants ()
  "Reads a list of constants from the mini-buffer, separated by whitespace.
Right now this does not do any consistency checking."
  (read-string "Constants: "
	       (if (null celf-trace-history) nil (car celf-trace-history))
	       'celf-trace-history))

(defun celf-trace-trace-all ()
  "Trace all clauses and families."
  (interactive)
  (celf-server-send-command "Trace.traceAll"))

(defun celf-trace-trace ()
  "Read list of constants and trace them."
  (interactive)
  (celf-server-send-command (concat "Trace.trace " (celf-read-constants))))

(defun celf-trace-untrace ()
  "Untrace all clauses and families."
  (interactive)
  (celf-server-send-command "Trace.untrace"))

(defun celf-trace-break-all ()
  "Set breakpoints on all clauses and families."
  (interactive)
  (celf-server-send-command "Trace.breakAll"))

(defun celf-trace-break ()
  "Read list of constants and set breakpoints."
  (interactive)
  (celf-server-send-command (concat "Trace.break " (celf-read-constants))))

(defun celf-trace-unbreak ()
  "Remove all breakpoints."
  (interactive)
  (celf-server-send-command "Trace.unbreak"))

(defun celf-trace-show ()
  "Show tracing and breakpoint information."
  (interactive)
  (celf-server-send-command "Trace.show")
  (celf-server-wait t))

(defun celf-timers-reset ()
  "Reset the Celf timers."
  (interactive)
  (celf-server-send-command "Timers.reset"))

(defun celf-timers-show ()
  "Show and reset the Celf timers."
  (interactive)
  (celf-server-send-command "Timers.show")
  (celf-server-wait t))

(defun celf-timers-check ()
  "Show the Celf timers without resetting them."
  (interactive)
  (celf-server-send-command "Timers.show")
  (celf-server-wait t))

(defun celf-server-restart ()
  "Restarts server and re-initializes configuration.
This is primarily useful during debugging of the Celf server code or
if the Celf server is hopelessly wedged."
  (interactive)
  (celf-server celf-server-program)
  (celf-server-configure (if *celf-config-buffer*
                            (buffer-file-name *celf-config-buffer*)
                          "sources.cfg")
                        "Server configured, now checking...")
  (celf-check-config))

;;;----------------------------------------------------------------------
;;; Celf Config minor mode
;;;----------------------------------------------------------------------

(defun celf-config-mode (&optional prefix)
  "Toggles minor mode for Celf configuration files.
This affects \\<celf-mode-map>
 celf-server-configure (\\[celf-server-configure])
 celf-save-check-config (\\[celf-save-check-config])
"
  (interactive "P")
  (make-local-variable 'celf-config-mode)
  (cond ((not (assq 'celf-config-mode minor-mode-alist))
	 (setq minor-mode-alist
	       (cons '(celf-config-mode " Config") minor-mode-alist))))
  (cond ((or (not celf-config-mode) prefix)
	 (setq celf-config-mode t)
	 (run-hooks 'celf-config-mode-hook))
	(t (setq celf-config-mode t))))

(defun celf-config-mode-check (&optional buffer)
  "Switch on the Celf Config minor mode if the ends in `.cfg'."
  (if (string-match "\\.cfg$" (buffer-file-name (or buffer (current-buffer))))
      (celf-config-mode t)))

;;;----------------------------------------------------------------------
;;; Support for creating a TAGS file for current Celf server configuration
;;;----------------------------------------------------------------------

(defun celf-tag (&optional tags-filename)
  "Create tags file for current configuration.
If the current configuration is sources.cfg, the tags file is TAGS.
If current configuration is named FILE.cfg, tags file will be named FILE.tag
Errors are displayed in the Celf server buffer.
Optional argument TAGS-FILENAME specifies alternative filename."
  (interactive)
  (celf-server-sync-config)
  (let* ((error-buffer (celf-get-server-buffer))
         (config-filename (buffer-file-name *celf-config-buffer*))
         (tags-file
          (or tags-filename
              (if (string-equal "sources.cfg"
				(file-name-nondirectory config-filename))
                  (concat (file-name-directory config-filename) "TAGS")
		(concat (file-name-sans-extension config-filename)
			".tag")))))
    (save-excursion
      (set-buffer error-buffer)
      (goto-char (point-max))
      (insert "Tagging configuration " config-filename " in file " tags-file "\n")
      (setq *celf-error-pos* (point-max)))
    (set-buffer *celf-config-buffer*)
    (celf-tag-files (rev-relativize *celf-config-list* default-directory)
                   tags-file error-buffer)
    ;; leaves us in error-buffer
    (if (get-buffer-process error-buffer)
        (set-marker (process-mark (get-buffer-process error-buffer))
                    (point-max)))))

(defun celf-tag-files (filelist &optional tags-filename error-buffer)
  "Create tags file for FILELIST, routing errors to buffer *tags-errors*.
Optional argument TAGS-FILENAME specifies alternative filename (default: TAGS),
optional argument ERROR-BUFFER specifies alternative buffer for error message
(default: *tags-errors*)."
  (let* ((tags-filename (or tags-filename "TAGS"))
         (tags-buffer (find-file-noselect tags-filename))
         (error-buffer (or error-buffer (new-temp-buffer "*tags-errors*"))))
    (save-excursion
      (set-buffer tags-buffer)
      (if (equal (point-min) (point-max))
          nil
        ;;(pop-to-buffer tags-buffer)
        ;;(if (yes-or-no-p "Delete current tags information? ")
        (delete-region (point-min) (point-max))
        ;;)
        ))
    (switch-to-buffer-other-window error-buffer)
    (while (not (null filelist))
      (celf-tag-file (car filelist) tags-buffer error-buffer)
      (setq filelist (cdr filelist)))
    (save-excursion
      (set-buffer tags-buffer)
      (save-buffer))))

(defun celf-tag-file (filename tags-buffer error-buffer)
  "Deposit tag information for FILENAME in TAGS-BUFFER, errors in ERROR-BUFFER."
  (let ((src-buffer (find-file-noselect filename))
        file-start file-end end-of-id tag-string)
    (save-excursion
      (set-buffer tags-buffer)
      (goto-char (point-max))
      (insert "\f\n" filename ",0\n")
      (setq file-start (point))
      (save-excursion
        (set-buffer src-buffer)
	(goto-char (point-min))
	(while (celf-next-decl filename error-buffer)
	  (setq end-of-id (point))
	  (beginning-of-line 1)
	  (setq tag-string
		(concat (buffer-substring (point) end-of-id)
			"\C-?" (int-to-string (current-line-absolute)) ","
			(int-to-string (point)) "\n"))
	  (goto-char end-of-id)
	  (if (not (celf-end-of-par))
	      (let ((error-line (current-line-absolute)))
		(save-excursion
		  (set-buffer error-buffer)
		  (goto-char (point-max))
		  (insert filename ":" (int-to-string error-line)
			  ".1 Warning: missing period\n"))))
	  (save-excursion
	    (set-buffer tags-buffer)
	    (insert tag-string))))
      (setq file-end (point-max))
      (goto-char (- file-start 2))
      (delete-char 1)
      (insert (int-to-string (- file-end file-start)))
      (goto-char (point-max)))))

(defvar celf-decl-pattern-noident
  "\\(%infix\\|%prefix\\|%postfix\\|%name\\|%freeze\\|%query\\|%querytabled\\|%tabled\\|%deterministic\\|%mode\\|%unique\\|%worlds\\|%covers\\|%total\\|%terminates\\|%trustme\\|%reduces\\|%prove\\|%assert\\|%establish\\|%use\\|%where\\|%include\\|%open\\)\\>"
  "Pattern used to match declarations which do not declare a new identifier.")

(defvar celf-decl-pattern-ident
  "\\(%abbrev\\|%clause\\|%define\\|%solve\\|%theorem\\|%block\\|%sig\\|%struct\\)[ \t]*\\([ \t]\\|\n\\)[ \t]*\\(\\<\\w+\\>\\)"
  "Pattern used to match declarations which declare a new identifer.
(match-beginning 3) to (match-end 3) will be the declared identifer.")

(defun celf-next-decl-x (%define-ends-decl filename error-buffer)
  "Set point after the identifier of the next declaration.
Return the declared identifier or `nil' if none was found.
FILENAME and ERROR-BUFFER are used if something appears wrong.
If %define-ends-decl, interpret %define as a declaration terminator
for the purpose of identifier fontification."
  (let ((id nil)
        end-of-id
	beg-of-id)
    (skip-celf-comments-and-whitespace)
    (while (and (not id) (not (eobp)))
      (setq beg-of-id (point))
      (if (zerop (skip-chars-forward *celf-id-chars*))
          ;; Not looking at id: skip ahead
	  (cond ((looking-at celf-decl-pattern-noident)
		 ;; valid decl: no warning
		 (celf-end-of-par-x %define-ends-decl))
		((looking-at celf-decl-pattern-ident)
		 ;; decl of identifer
		 (setq beg-of-id (match-beginning 3))
		 (setq end-of-id (match-end 3))
		 (goto-char end-of-id)
		 (setq id (buffer-substring beg-of-id end-of-id)))
		(t ;; unrecognized text
		 (skip-ahead filename (current-line-absolute) "Unrecognized declaration format"
			     error-buffer)))
        (setq end-of-id (point))
        (skip-celf-comments-and-whitespace)
        (if (not (looking-at "[:=]"))	; c : V or c = U or c : V = U
            ;; Not looking at valid decl: skip ahead
            (skip-ahead filename (current-line-absolute end-of-id)
			"No colon or equal sign"
                        error-buffer)
          (goto-char end-of-id)
          (setq id (buffer-substring beg-of-id end-of-id))))
      (skip-celf-comments-and-whitespace))
    id))

(defun celf-next-decl (filename error-buffer)
  "Set point after the identifier of the next declaration.
Return the declared identifier or `nil' if none was found.
FILENAME and ERROR-BUFFER are used if something appears wrong."
  (celf-next-decl-x nil filename error-buffer))

(defun celf-font-next-decl (filename error-buffer)
  "Set point after the identifier of the next declaration.
Return the declared identifier or `nil' if none was found.
FILENAME and ERROR-BUFFER are used if something appears wrong.
Interprets %define as a declaration terminator for the purpose
of identifier fontification."
  (celf-next-decl-x t filename error-buffer))

(defun skip-ahead (filename line message error-buffer)
  "Skip ahead when syntactic error was found.
A parsable error message constited from FILENAME, LINE, and MESSAGE is
deposited in ERROR-BUFFER."
  (if error-buffer
      (save-excursion
	(set-buffer error-buffer)
	(goto-char (point-max))
	(insert filename ":" (int-to-string line) ".1 Warning: "
		message "\n")))
  (celf-end-of-par))

(defun current-line-absolute (&optional char-pos)
  "Return line number of CHAR-POS (default: point) in current buffer.
Ignores any possible buffer restrictions."
  (1+ (count-lines 1 (or char-pos (point)))))

(defun new-temp-buffer (&optional name)
  "Create or delete contents of buffer named \"*temp*\" and return it.
Optional argument NAME specified an alternative name."
  (if (not name) (setq name "*temp*"))
  (if (get-buffer name)
      (save-excursion
        (set-buffer name)
        (delete-region (point-min) (point-max))
        (get-buffer name))
    (get-buffer-create name)))

(defun rev-relativize (filelist dir)
  "Reverse and relativize FILELIST with respect to DIR."
  (let ((newlist nil))
    (while (not (null filelist))
      (setq newlist
            (cons (file-relative-name (car filelist) dir) newlist))
      (setq filelist (cdr filelist)))
    newlist))


;;;----------------------------------------------------------------------
;;; Celf-SML mode
;;;----------------------------------------------------------------------

(defvar celf-sml-mode-map nil
  "The keymap used in Celf-SML mode.")

(cond ((not celf-sml-mode-map)
       ;;(setq celf-sml-mode-map (full-copy-sparse-keymap comint-mode-map))
       ;; fixed for Emacs 19.25.  -fp Thu Oct 27 09:08:44 1994
       (setq celf-sml-mode-map (copy-keymap comint-mode-map))
       (install-basic-celf-keybindings celf-sml-mode-map)
       ))

(defconst celf-sml-prompt-regexp "^\\- \\|^\\?\\- ")

(defun expand-dir (dir)
  "Expand argument and check that it is a directory."
  (let ((expanded-dir (file-name-as-directory (expand-file-name dir))))
    (if (not (file-directory-p expanded-dir))
        (error "%s is not a directory" dir))
    expanded-dir))

(defun celf-sml-cd (dir)
  "Make DIR become the Celf-SML process' buffer's default directory and
furthermore issue an appropriate command to the inferior Celf-SML process."
  (interactive "DChange default directory: ")
  (let ((expanded-dir (expand-dir dir)))
    (save-excursion
      (set-buffer (celf-sml-process-buffer))
      (setq default-directory expanded-dir)
      (comint-simple-send (celf-sml-process) (concat "Celf.OS.chDir \"" expanded-dir "\";")))
    ;;(pwd)
    ))

(defconst celf-sml-cd-regexp "^\\s *cd\\s *\"\\([^\"]*\\)\""
  "Regular expression used to match cd commands in Celf-SML buffer.")

(defun celf-sml-directory-tracker (input)
  "Checks input for cd commands and changes default directory in buffer.
As a side-effect, it sets *celf-last-region-sent* to NIL to indicate interactive
input.  As a second side-effect, it resets the *celf-error-pos*.
Used as comint-input-sentinel in Celf-SML buffer."
  (if (celf-input-filter input)
      (setq *celf-last-region-sent* nil))
  (setq *celf-last-input-buffer* (current-buffer))
  (setq *celf-error-pos* (marker-position (process-mark (celf-sml-process))))
  (cond ((string-match celf-sml-cd-regexp input)
         (let ((expanded-dir (expand-dir (substring input
                                                    (match-beginning 1)
                                                    (match-end 1)))))
           (setq default-directory expanded-dir)
           (pwd)))))

(defun celf-sml-mode ()
  "Major mode for interacting with an inferior Celf-SML process.

The following commands are available:
\\{celf-sml-mode-map}

An Celf-SML process can be started with \\[celf-sml].

Customisation: Entry to this mode runs the hooks on celf-sml-mode-hook.

You can send queries to the inferior Celf-SML process from other buffers.

Commands:
Return after the end of the process' output sends the text from the 
    end of process to point.
Return before the end of the process' output copies the current line
    to the end of the process' output, and sends it.
Delete converts tabs to spaces as it moves back.
Tab indents for Celf; with argument, shifts rest
    of expression rigidly with the current line.
C-M-q does Tab on each line starting within following expression.
Paragraphs are separated only by blank lines.  % start single comments,
delimited comments are enclosed in %{...}%.
If you accidentally suspend your process, use \\[comint-continue-subjob]
to continue it."
  (interactive)
  (kill-all-local-variables)
  (comint-mode)
  (setq comint-prompt-regexp celf-sml-prompt-regexp)
  (setq comint-input-filter 'celf-input-filter)
  ;; changed for XEmacs 19.16 Sat Jun 13 11:28:53 1998
  (add-hook 'comint-input-filter-functions 'celf-sml-directory-tracker
	    nil t)
  (celf-mode-variables)

  ;; For sequencing through error messages:
  (make-local-variable '*celf-error-pos*)
  (setq *celf-error-pos* (point-max))
  ;; Workaround for problem with Lucid Emacs version of comint.el:
  ;; must exclude double quotes " and must include $ and # in filenames.
  (make-local-variable 'comint-match-partial-pathname-chars)
  (setq comint-match-partial-pathname-chars 
        "^][<>{}()!^&*\\|?`'\" \t\n\r\b")

  (setq major-mode 'celf-sml-mode)
  (setq mode-name "Celf-SML")
  (setq mode-line-process '(": %s"))
  (use-local-map celf-sml-mode-map)

  (run-hooks 'celf-sml-mode-hook))

(defun celf-sml (&optional cmd)
  "Run an inferior Celf-SML process in a buffer *celf-sml*.
If there is a process already running in *celf-sml*, just
switch to that buffer.  With argument, allows you to change the program
which defaults to the value of celf-sml-program.  Runs the hooks from
celf-sml-mode-hook (after the comint-mode-hook is run).

Type \\[describe-mode] in the process buffer for a list of commands."
  (interactive (list (and current-prefix-arg
			  (read-string "Run Celf-SML: " celf-sml-program))))
  (let ((cmd (or cmd celf-sml-program)))
    (cond ((not (comint-check-proc (celf-sml-process-buffer)))
	   ;; process does not already exist
	   (set-buffer (apply 'make-comint "celf-sml" cmd nil celf-sml-args))
	   ;; in case we are using SML mode (for error tracking)
	   (if (boundp 'sml-buffer)
	       (set 'sml-buffer (celf-sml-process-buffer)))
	   (celf-sml-mode))))
  (switch-to-buffer (celf-sml-process-buffer)))

(defun switch-to-celf-sml (eob-p)
  "Switch to the Celf-SML process buffer.
With argument, positions cursor at end of buffer."
  (interactive "P")
  (if (celf-sml-process-buffer)
      (pop-to-buffer (celf-sml-process-buffer))
      (error "No current process buffer. "))
  (cond (eob-p
         (push-mark)
         (goto-char (point-max)))))

(defun display-celf-sml-buffer (&optional buffer)
  "Display the Celf-SML buffer so that the end of output is visible."
  ;; Accept output from Celf-SML process
  (sit-for 1)
  (let* ((celf-sml-buffer (if (null buffer) (celf-sml-process-buffer)
                       buffer))
         (_ (set-buffer celf-sml-buffer))
         (celf-sml-process (celf-sml-process))
         (proc-mark (process-mark celf-sml-process))
         (_ (display-buffer celf-sml-buffer))
         (celf-sml-window (get-buffer-window celf-sml-buffer)))
    (if (not (pos-visible-in-window-p proc-mark celf-sml-window))
        (progn
          (push-mark proc-mark)
          (set-window-point celf-sml-window proc-mark)))))

(defun celf-sml-send-string (string)
  "Send the given string to the Celf-SML process."
  (setq *celf-last-input-buffer* (celf-sml-process-buffer))
  (comint-send-string (celf-sml-process) string))

(defun celf-sml-send-region (start end &optional and-go)
  "Send the current region to the inferior Celf-SML process.
Prefix argument means switch-to-celf-sml afterwards.
If the region is short, it is sent directly, via COMINT-SEND-REGION."
  (interactive "r\nP")
  (if (> start end)
      (celf-sml-send-region end start and-go)
    ;; (setq celf-sml-last-region-sent (list (current-buffer) start end))
    (let ((cur-buffer (current-buffer))
          (celf-sml-buffer (celf-sml-process-buffer)))
      (switch-to-buffer celf-sml-buffer)
      ;; (setq sml-error-pos (marker-position (process-mark (celf-sml-process))))
      (setq *celf-last-input-buffer* celf-sml-buffer)
      (switch-to-buffer cur-buffer))
    (comint-send-region (celf-sml-process) start end)
    (if (not (string= (buffer-substring (1- end) end) "\n"))
        (comint-send-string (celf-sml-process) "\n"))
    ;; Next two lines mess up when an Celf error occurs, since the
    ;; newline is not read and later messes up counting.
    ;; (if (not and-go)
    ;;  (comint-send-string (celf-sml-process) "\n"))
    (if and-go (switch-to-celf-sml t)
      (if celf-sml-display-queries (display-celf-sml-buffer)))))

(defun celf-sml-send-query (&optional and-go)
  "Send the current declaration to the inferior Celf-SML process as a query.
Prefix argument means switch-to-celf-sml afterwards."
  (interactive "P")
  (let* ((par (celf-current-decl))
         (query-start (nth 0 par))
         (query-end (nth 1 par)))
    (celf-sml-set-mode 'CELF)
    (celf-sml-send-region query-start query-end and-go)))

(defun celf-sml-send-newline (&optional and-go)
  "Send a newline to the inferior Celf-SML process.
If a prefix argument is given, switches to Celf-SML buffer afterwards."
  (interactive "P")
  (celf-sml-send-string "\n")
  (if and-go (switch-to-celf-sml t)
    (if celf-sml-display-queries (display-celf-sml-buffer))))

(defun celf-sml-send-semicolon (&optional and-go)
  "Send a semi-colon to the inferior Celf-SML process.
If a prefix argument is given, switched to Celf-SML buffer afterwards."
  (interactive "P")
  (celf-sml-send-string ";\n")
  (if and-go (switch-to-celf-sml t)
    (if celf-sml-display-queries (display-celf-sml-buffer))))

(defun celf-sml-status (&optional buffer)
  "Returns the status of the Celf-SML process.
This employs a heuristic, looking at the contents of the Celf-SML buffer.
Results:
 NONE --- no process
 ML   --- ML top level
 CELF  --- Celf top level
 MORE --- asking whether to find the next solution
 UNKNOWN --- process is running, but can't tell status."
  (let* ((celf-sml-buffer (or buffer (celf-sml-process-buffer)))
         (celf-sml-process (get-buffer-process celf-sml-buffer)))
    (if (null celf-sml-process)
        'NONE
      (save-excursion
        (set-buffer celf-sml-buffer)
        (let ((buffer-end (buffer-substring (max (point-min) (- (point-max) 3))
                                            (point-max))))
          (cond ((string-match "\\?- " buffer-end) 'CELF)
                ((string-match "\n- " buffer-end) 'ML)
                ((string-match "More\\? " buffer-end) 'MORE)
                (t 'UNKNOWN)))))))

(defvar celf-sml-init "Celf.Config.load (Celf.Config.read \"sources.cfg\");\n"
  "Initial command sent to Celf-SML process when started during celf-sml-set-mode 'CELF.")

(defun celf-sml-set-mode (mode &optional buffer)
  "Attempts to read and if necessary correct the mode of the Celf-SML buffer.
This does not check if the status has been achieved.  It returns NIL
if the status is unknown and T if it believes the status should have
been achieved.  This allows for asynchronous operation."
  (cond
    ((eq mode 'ML)
     (let ((status (celf-sml-status)))
       (cond ((eq status 'NONE) (celf-sml) 't)
             ((eq status 'ML) 't)
             ((eq status 'CELF) (celf-sml-send-string "") 't)
             ((eq status 'MORE) (celf-sml-send-string "q\n") 't)
             ((eq status 'UNKNOWN) nil))))
    ((eq mode 'CELF)
     (let ((status (celf-sml-status)))
       (cond ((eq status 'NONE)
              (celf-sml)
              (celf-sml-send-string celf-sml-init)
              (celf-sml-send-string "Celf.top ();\n") 't)
             ((eq status 'ML)
              (celf-sml-send-string "Celf.top ();\n") 't)
             ((eq status 'CELF) 't)
             ((eq status 'MORE) (celf-sml-send-string "\n") 't)
             ((eq status 'UNKNOWN) nil))))
    (t (error "celf-sml-set-mode: illegal mode %s" mode))))

(defun celf-sml-quit ()
  "Kill the Celf-SML process."
  (interactive)
  (kill-process (celf-sml-process)))

(defun celf-sml-process-buffer ()
  "Returns the current Celf-SML process buffer."
  (get-buffer "*celf-sml*"))

(defun celf-sml-process (&optional buffer)
  "Returns the current Celf-SML process."
  (let ((proc (get-buffer-process (or buffer (celf-sml-process-buffer)))))
    (or proc
        (error "No current process."))))

;;;----------------------------------------------------------------------
;;; 2Celf-SML minor mode for Celf
;;; Some keybindings now refer to Celf-SML instead of the Celf server.
;;; Toggle with celf-to-celf-sml-mode
;;;----------------------------------------------------------------------

(defvar celf-to-celf-sml-mode nil
  "Non-NIL means the minor mode is in effect.")

(defun install-celf-to-celf-sml-keybindings (map)
  ;; Process commands:
  (define-key map "\C-c\C-r" 'celf-sml-send-region)
  (define-key map "\C-c\C-e" 'celf-sml-send-query)
  (define-key map "\C-c\C-m" 'celf-sml-send-newline)
  (define-key map "\C-c\n" 'celf-sml-send-newline)
  (define-key map "\C-c;" 'celf-sml-send-semicolon)
  (define-key map "\C-cd" 'celf-sml-cd)
  )

(defvar celf-to-celf-sml-mode-map nil
  "Keymap for celf-to-celf-sml minor mode.")

(cond ((not celf-to-celf-sml-mode-map)
       (setq celf-to-celf-sml-mode-map (make-sparse-keymap))
       (install-basic-celf-keybindings celf-to-celf-sml-mode-map)
       (install-celf-keybindings celf-to-celf-sml-mode-map)
       ;; The next line shadows certain bindings to refer to
       ;; Celf-SML instead of the Celf server.
       (install-celf-to-celf-sml-keybindings celf-to-celf-sml-mode-map)))

(defun celf-to-celf-sml-mode (&optional prefix)
  "Toggles minor mode for sending queries to Celf-SML instead of Celf server.
Specifically:   \\<celf-to-celf-sml-mode-map>
 \\[celf-sml-send-query] (for sending queries),
 \\[celf-sml-send-newline] (for sending newlines) and
 \\[celf-sml-send-semicolon] (for sending `;')
are rebound.

Mode map
========
\\{celf-to-celf-sml-mode-map}
"
  (interactive "P")
  (make-local-variable 'celf-to-celf-sml-mode)
  (cond ((not (assq 'celf-to-celf-sml-mode minor-mode-alist))
         (setq minor-mode-alist
               (cons '(celf-to-celf-sml-mode " 2Celf-SML")
                     minor-mode-alist))))
  (cond ((or (not celf-to-celf-sml-mode) prefix)
         (setq celf-to-celf-sml-mode t)
         (use-local-map celf-to-celf-sml-mode-map)
         (run-hooks 'celf-to-celf-sml-mode-hook))
        (t
         (setq celf-to-celf-sml-mode nil)
         (use-local-map celf-mode-map))))

;;;----------------------------------------------------------------------
;;; Celf mode menus
;;; requires auc-menu utilities
;;;----------------------------------------------------------------------

(cond
 ((string-match "XEmacs" emacs-version) ;; XEmacs nee Lucid Emacs
  (defun radio (label callback condition)
    (vector label callback ':style 'radio ':selected condition))
  (defun toggle (label callback condition)
    (vector label callback ':style 'toggle ':selected condition))
  (defun disable-form (label callback condition)
    (vector label callback condition))
  )
 (t ;; FSF Emacs 19
  (defun radio (label callback condition)
    (vector label callback t))
  (defun toggle (label callback condition)
    (vector label callback t))
  (defun disable-form (label callback condition)
    (cond ((symbolp condition) (vector label callback condition))
	  (t (vector label callback t))))
  ))

(defconst celf-at-point-menu
  '("At Point"
    ["Constant" celf-type-const t]
    ;["Type" celf-type-at-point nil]	;disabled for Celf 1.2
    ;["Expected Type" celf-expected-type-at-point nil] ;disabled
    ;["List Completions" celf-completions-at-point nil]	;disabled
    ;["Complete" celf-complete nil] ;disabled
    )
  "Menu for commands applying at point.")

(defconst celf-print-menu
  '("Print"
    ["Signature" celf-print-signature t]
    ["Program" celf-print-program t]
    ("TeX"
     ["Signature" celf-print-tex-signature t]
     ["Program" celf-print-tex-program t]))
  "Menu for printing commands.")

(defconst celf-recon-menu
  (` ("Reconstruction"
      (, (toggle "trace" '(celf-toggle-recon-trace)
		 '(string-equal celf-recon-trace "true")))
      ["traceMode" (celf-set-parm "Recon.traceMode") t])))

(defconst celf-trace-menu
  (` ("Trace"
      ("trace"
       ["All" celf-trace-trace-all t]
       ["None" celf-trace-untrace t]
       ["Some" celf-trace-trace t])
      ("break"
       ["All" celf-trace-break-all t]
       ["None" celf-trace-unbreak t]
       ["Some" celf-trace-break t])
      ["show" celf-trace-show t]
      ("detail"
       (, (radio "0" '(celf-set "Trace.detail" "0") '(equal celf-trace-detail "0")))
       (, (radio "1*" '(celf-set "Trace.detail" "1") '(equal celf-trace-detail "1")))
       (, (radio "2" '(celf-set "Trace.detail" "2") '(equal celf-trace-detail "2")))))))

(defconst celf-server-state-menu
  '("Server State"
    ["Configure" celf-server-configure t]
    ["Interrupt" celf-server-interrupt t]
    ["Reset" celf-reset t]
    ["Start" celf-server t]
    ["Restart" celf-server-restart t]
    ["Quit" celf-server-quit t])
  "Menu for commands affecting server state.")

(defconst celf-error-menu
  '("Error Tracking"
    ["Next" celf-next-error t]
    ["Goto" celf-goto-error t])
  "Menu for error commands.")

(defconst celf-tags-menu
  '("Tags"
    ["Find" find-tag t]
    ["Find Other Window" find-tag-other-window t]
    ["Query Replace" tags-query-replace t]
    ["Search" tags-search t]
    ["Continue" tags-loop-continue t]
    ["Create/Update" celf-tag t])
  "Menu for tag commands.")

(defun celf-toggle-server-display-commands ()
  (setq celf-server-display-commands (not celf-server-display-commands)))

(defconst celf-options-menu
  (` ("Options"
      (, (toggle "Display Commands" '(celf-toggle-server-display-commands)
		 'celf-server-display-commands))
      ("chatter"
       (, (radio "0" '(celf-set "chatter" "0") '(equal celf-chatter "0")))
       (, (radio "1" '(celf-set "chatter" "1") '(equal celf-chatter "1")))
       (, (radio "2" '(celf-set "chatter" "2") '(equal celf-chatter "2")))
       (, (radio "3*" '(celf-set "chatter" "3") '(equal celf-chatter "3")))
       (, (radio "4" '(celf-set "chatter" "4") '(equal celf-chatter "4")))
       (, (radio "5" '(celf-set "chatter" "5") '(equal celf-chatter "5")))
       (, (radio "6" '(celf-set "chatter" "6") '(equal celf-chatter "6"))))
      (, (toggle "doubleCheck" '(celf-toggle-double-check)
		 '(string-equal celf-double-check "true")))
      (, (toggle "unsafe" '(celf-toggle-unsafe)
		 '(string-equal celf-unsafe "true")))
      (, (toggle "autoFreeze" '(celf-toggle-auto-freeze)
		 '(string-equal celf-auto-freeze "true")))
      ("Print."
       (, (toggle "implicit" '(celf-toggle-print-implicit)
		  '(string-equal celf-print-implicit "true")))
       ["depth" (celf-set-parm "Print.depth") t]
       ["length" (celf-set-parm "Print.length") t]
       ["indent" (celf-set-parm "Print.indent") t]
       ["width" (celf-set-parm "Print.width") t])
      ("Trace.detail"
       (, (radio "0" '(celf-set "Trace.detail" "0") '(equal celf-trace-detail "0")))
       (, (radio "1*" '(celf-set "Trace.detail" "1") '(equal celf-trace-detail "1")))
       (, (radio "2" '(celf-set "Trace.detail" "2") '(equal celf-trace-detail "2"))))
      ("Compile."
       (, (toggle "optimize" '(celf-toggle-compile-optimize)
		  '(string-equal celf-compile-optimize "true"))))
      ("Prover."
       ["strategy" (celf-set-parm "Prover.strategy") t]
       ["maxSplit" (celf-set-parm "Prover.maxSplit") t]
       ["maxRecurse" (celf-set-parm "Prover.maxRecurse") t])
      ("Table."
       ["strategy" (celf-set-parm "Table.strategy") t]
       ["strengthen" (celf-set-parm "Table.strengthen") t])
      ["Reset Menubar" celf-reset-menu t]))
  "Menu to change options in Celf mode.")

(defconst celf-timers-menu
  '("Timing"
    ["Show and Reset" celf-timers-show t]
    ["Check" celf-timers-check t]
    ["Reset" celf-timers-reset t]))

;(autoload 'toggle-celf-font-immediate "celf-font"
;  "Toggle experimental immediate highlighting in font-lock mode.")
(autoload 'celf-font-fontify-decl "celf-font"
  "Fontify current declaration using font-lock minor mode.")
(autoload 'celf-font-fontify-buffer "celf-font"
  "Fontify current buffer using font-lock minor mode.")

(defconst celf-syntax-menu
  (` ("Syntax Highlighting"
      ["Highlight Declaration" celf-font-fontify-decl t]
      ["Highlight Buffer" celf-font-fontify-buffer t]
      ;(, (toggle "Immediate Highlighting" 'toggle-celf-font-immediate
      ;'font-lock-mode))
      ))
  "Menu for syntax highlighting in Celf mode.")

(easy-menu-define celf-menu (list celf-mode-map)
  "Menu for Celf mode.
This may be selected from the menubar.  In XEmacs, also bound to Button3."
  (list
   "Celf"
   ["Display Server" celf-server-display t]
   ["Check Configuration" celf-save-check-config t]
   ["Check File" celf-save-check-file t]
   ["Check Declaration" celf-check-declaration t]
   celf-at-point-menu
   celf-error-menu
   celf-options-menu
   celf-syntax-menu
   celf-recon-menu
   celf-trace-menu
   celf-tags-menu
   celf-print-menu
   celf-timers-menu
   celf-server-state-menu
   ["Info" celf-info t]))

(defun celf-add-menu ()
  "Add Celf menu to menubar."
  (easy-menu-add celf-menu celf-mode-map))

(defun celf-remove-menu ()
  "Remove Celf menu from menubar."
  (easy-menu-remove celf-menu))

(defun celf-reset-menu ()
  "Reset Celf menu."
  (interactive)
  (celf-remove-menu)
  (celf-add-menu))

;;;----------------------------------------------------------------------
;;; Celf Server mode menu
;;;----------------------------------------------------------------------

(easy-menu-define celf-server-menu (list celf-server-mode-map)
  "Menu for Celf Server mode.
This may be selected from the menubar.  In XEmacs, also bound to Button3."
  (list
   "Celf-Server"
   ;; ["Display Server" celf-server-display t]
   ["Check Configuration" celf-save-check-config t]
   ;; ["Check File" celf-save-check-file nil]
   ;; ["Check Declaration" celf-check-declaration nil]
   ;; ["Check Query" celf-check-query nil]
   ;; ["Solve Query" celf-solve-query nil]
   ;; ["At Point" () nil]
   celf-error-menu
   celf-options-menu
   celf-trace-menu
   celf-tags-menu
   celf-print-menu
   celf-timers-menu
   celf-server-state-menu
   ["Info" celf-info t]))

(defun celf-server-add-menu ()
  "Add Celf menu to menubar."
  (easy-menu-add celf-server-menu celf-server-mode-map))

(defun celf-server-remove-menu ()
  "Remove Celf menu from menubar."
  (easy-menu-remove celf-server-menu))

(defun celf-server-reset-menu ()
  "Reset Celf menu."
  (interactive)
  (celf-server-remove-menu)
  (celf-server-add-menu))

(provide 'celf)
